<br/> - разрыв строки (Shift+Enter)
<p></p> - параграф, абзац (Enter)
<hr/> - горизонтальная линия (horisontal rule)
<span></span> - строчный элемент (выделяет выделенную строку без переноса)
<b> - Жирный текст
<strong> - Важный текст
font-weight: bold;
<i> - текст Курсив (наклонный)
<em> - текст Акцентирует внимание (наклонный)
<mark> - Маркерованный текст
<small> - Небольшой текст
<del> - Удаленный (зачеркнутый) текст
<ins> - Вставленный (добавить) текст
<sub> - Подстрочный текст
<sup> - Надстрочный текст

<p contenteditable="true"> - делает параграф редактируемым

lorem20 - набор рыбьего текста 

<a href="">Наименование ссылки</a> - ссылка 
<a href="" target="_blank"> </a> - ссылка в новой владке
<img src="" alt=""> - тег для вставки URL или локального путя изображения. "alt" используется для написания текстового обьяснения, в случае если фото будет недоступно
<_ target="_blank"> - открытие в новой вкладке
<a href="https://webref.ru"><img src="image/shark.jpg" alt=""></a> - ссылка в изображении

<ol></ol> - упорядоченная оболочка для пунктов списка
<ul></ul> - неупорядоченный, dots список 
<ol/<ul type="I/square"> Для изменения нумерации используют "type" 
<li></li> - сам список (пишется внутри <ul></ul> или <ol></ol>)

<li value="3"> -ставит значение 3 для нумерации строки
style= "list-style-type: disc/circle/square/decimal/georgian/trad-chinese-informal/kannada; "

ul>li{Элемент $}*5 - Появится 5 строк с наименованием "Элемент".При добавлении "$", появится нумерация   

<table></table> - оболочка для тегов таблицы
<thead></thead> - заголовок таблицы (столбцы именуются как <th></th>, а не как <td></td>)
<tr></tr> - строка таблицы (table rool)
<th></th> - столбцы заголовка таблицы
<tbody></tbody> - основное тело таблицы
<tr></tr> - строка таблицы (table rool)
<td></td> - столбцы в теле таблицы (внутри тега <tr></tr>) (table data)

<form></form> - поле для ввода
<label for="логин">Логин</label> -  текст перед полем ввода. Тег "for" связывается с тегом "id" и при нажатии на текст выделяется форма.
<input type="text/password/email/number/range/date/color/message/" id="логин"> - что будет вводиться в поле ввода.

<section id="sex">
    <option value="Мужчина">м</option>
    <option value="Женщина">ж</option>
</section> - выпадающий из прошлого список

<value=""> - атрибут тега, определяет что будет написано
<id=""> и <class=""> - "id" не должно повторяться, "class" может и используется для стилистики
<div></div> - блочный элемент (выделяет и переносит абзацом)
<header>/<footer>/<nav>/<article>/<section (группа для article)>/<aside (для меню слева-справа)> - это все замена <div> для правильной индексации и нормализации поиска сайта

<figure>
   <img src="" alt="">
   <figcaption>Подпись</figcaption> - связывает подпись с картинкой
</figure> 
<details>
   <summary></summary> - Описание и краткое заглавие выпадающего описания
</details>

_______________________________
CSS
   h1       {color: red}
-селектор {свойство: значение}
-cвойство: функции (значение);
.class > p - ображение только к детям класса (не учитывая детей детей)
---------------------------------------------------------
font-family - выбор шрифта (Roboto,Times..)
font-size - размер текста
font-weight - толщина начертание шрифта (аналог <strong>)
text-transform: uppercase - заглавный шрифт
---------------------------------------------------------
width= "150" - устанавливает ширину элемента (ширину области)
word-spacing - растояние между словами
letter-spacing - растояние между символами
line-height - межстрочный интервал
text-decoration: underline; - подчеркивания, зачеркивания, none
<del></del> -зачеркнутый текст или (представляет диапазон текста, который был удалён из документа)
<ins></ins> - подчеркивание или (показывает что было добавлено в код)
opacity: 0.4 - непрозрачность элемента
---------------------------------------------------------
#ff0000 - красный; color: #00ff00 зеленый; color: #00ff00 синий;
color: rgba(0, 255, 0, 0.2) - цвета и прозрачность
-Дизайнт цвета можно копировать с браузера с помощью пипетки из "Иследовать элемент"
---------------------------------------------------------
-CSS код можно писать как в  HTML в <head><style></style></head>
 Можно писать инлайн <header style="color: black;"></header>
 Можно писать так же отдельно в css файле: <link rel="stylesheet" href="Index.css0">
---------------------------------------------------------
padding: 0px 20px 0px 20px - можно написать сразу для 4х сторон. Отсчёт идёт по часовой стрелке.
padding - внутренние отступы (внутри рамки)
margine - внешние отступы (за рамкой)
margin: auto; - выравнивание по центру 
bottom - подвал/низ
top - верх
---------------------------------------------------------
* {} - селектор задает значение всему на странице
#id {} - стилизация через ID: #id {}
.card p {} -для обращения к безликому(повторяющемуся в др местах) дочернему тегу через родительский указываем путь: .card p {}
@import url() - Импорт шрифта
div p - выбор всех элементов p внутри элемента div
---------------------------------------------------------
filter: blur(2px)
filter: grayscale (0%) - сепия
filter: opacity (100%) - непрозрачность
filter: saturate (100%) - насыщенность 
filter: contrast (100%) - контрастность
background: linear-gradient ( 45deg, blue, lightGreen) - градиент
cursor:pointer; - изменение курсора при наведении
---------------------------------------------------------
background-image: url("img/whistle.svg"); - выставление бэкграунд фото
background-repeat: no-repeat; - не размазывать фон (иконки) по всему блоку
background-position: center top; - местоположение бэкграунд изображения (может выступать иконкой, а не фоном сайта)
background-position: right 35% bottom 45%;
background-size: - размер изображения
---------------------------------------------------------
list-style: none или url('/media/examples/rocket.svg'); - что будет показываться в пунктах(точках) списка
---------------------------------------------------------
.cards a:hover {} - интерактивность при наведении на элемент, меняет цвет/размер шрифта итд 
transition: all .2s; - анимация увеличения для селектора (например для ссылки при наведении)
.table:nth-child(odd/even/1/2/3..) - выделение столбцов таблицы
---------------------------------------------------------
Flex
---------------------------------------------------------
Используется для родительского элемента:
<div class="container"><div></div></div>

display: flex; - создаёт флекс контейнер 
flex-direction: row/column; - элементы в строку/ в колонке

.container { justify-content: center; } - установка элемента по центру
justify-content: space-around; - равномерное распределение элементов по контейнеру (space-around/space-between/center/start/end)
---------------------------------------------------------
_______________________________
JavaScript 
JS - регистрозависимый язык
---------------------------------------------------------
Функция isNaN() возвращает true, если значение не число, равно NaN (Not-a-Number), и false, если нет.
---------------------------------------------------------
== 	равно
=== 	равное значение и равный тип
!= 	не равный
---------------------------------------------------------
unshift - Добавление новых элементов в начало массива
var fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];
fruits.unshift("Lemon","Pineapple");
---------------------------------------------------------
Math.max([x[, y[, …]]])- Возвращает наибольшее число из своих аргументов.
---------------------------------------------------------
Массивы: 
let fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива
---------------------------------------------------------
Цикл 
for (начало; условие; шаг) {
  // ... тело цикла ...
}
for (let i = 0; i < 3; i++) { 
   // выведет 0, затем 1, затем 2
  alert(i);
}
---------------------------------------------------------
Чтобы вывести объединить текстовую строку и переменную является знак «+». Чтобы сообщить о том, что здесь закончился текст и начинается переменная Javascript, нужно открыть и закрыть кавычки.
alert( "Привет " + name + "!");
---------------------------------------------------------
<script defer src="js/vendor/jquery.js"></script>
async - выполение сриптов по мере возможности, "рандомно"
defer - выполение в строгой последовательности их размещения
---------------------------------------------------------
Math.floor() - округление вниз. Округляет аргумент до ближайшего меньшего целого.
---------------------------------------------------------
querySelector - "найди и принеси элемент" селектор запросов (en/ru)
document.querySelector('селектор');
document.querySelector('.page'); - js ищет на странице элемент с классом "page"
---------------------------------------------------------
Для добавления js в html, <script></script> добавляется перед </body>
Для подключения js к html необходимо ввести в конце <body> <script src="index.js"></script> </body>
---------------------------------------------------------
Тестирование с помощью консоли (вывод в консоль):
console.log(document.querySelector('.page'));
console.log - обращение к консоли
(document. ___ ) - "документ" поиск по данному файлу 
---------------------------------------------------------
classList.remove - удаление класса 
элемент.classList.remove('класс');
document.querySelector('.page').classList.remove('light-theme');
Сначала ищем селектор, во втором моменте "." не ставится, тк js знает что это класс
---------------------------------------------------------
classList.add - добавление класса 
элемент.classList.add('класс');
---------------------------------------------------------
Переменная — это способ сохранить данные, дав им понятное название (ярлык с файлами).
Константа - почти тоже самое что и переменная, только значение которой нельзя менять
---------------------------------------------------------
let - с помощью него можно создать (обьявить) переменную. 
let: - "пусть/допустим" за которым следует имя для вашей переменной. 
Чтобы задать несколько значений let 
let numbers = [10, 4, 100, -5, 54, 2]; - массив

У переменных после их наименования с помощью "let" должно быть присвоено значение.
" = " - с помощью знака равенства присваиваем значение переменной
let variableName = 'Я значение переменной!';

let header = document.querySelector('header'); - при вводе переменной "header", JS выполняет функцию поиска по документу селектора header
---------------------------------------------------------
Условия / условные выравнивания (Conditionals) - it/else/else if 
---------------------------------------------------------
События (Events) - это действия, которые происходят в браузере, например, нажатие кнопки или загрузка страницы или воспроизведение видео, в ответ на которые мы можем запускать блоки кода.
Конструкции прослушивающие события - прослушиватели событий
Блоки кода выполняемы в ответ на срабатывание события - обработчики событий
---------------------------------------------------------
Циклы (Loops)
for - для / of - из

const fruits = ['apples', 'bananas', 'cherries'];
for (const fruit of fruits) {
  console.log(fruit);
}
Данный цикл будет поочередно выводить значения массива константы "fruits"
Строка for (const fruit of fruits) говорит:
1.Получи первый элемент из fruits.
2.Установи переменную fruit для этого элемента, затем запусти код между скобками {}.
3.Получи следующий элемент из fruits и повторяй, пока не дойдешь до конца.
---------------------------------------------------------
Массив - массив — это набор элементов
Строка const fruit = ['apples', 'bananas', 'cherries']; создает массив.
---------------------------------------------------------
focus() - 
guessField.focus(); помещает курсор в текстовое поле при загрузки страницы 
---------------------------------------------------------
alert() - выводит модальное окно на странице
const years = prompt('Сколько вам лет?', 100);
alert('Вам ' + years + ' лет!')

prompt() - выводит окно с строкой заполнения и его возможным заполнением('Наименование окна','Запись в строке заполнения') 
Сохранить в переменную: const userName = prompt('Как вас зовут?');

confirm() - диалоговое окно с сообщением и кнопками выбора "cancel" - false, "ok" - true.
---------------------------------------------------------
Чтобы вывести в консоль в одну строку несолько параметров:
console.log(`${myInfoText[0]} ${myInfoText[441]}`)
---------------------------------------------------------
Определяем переменную let: 
let name = 'Petr the pig';
Переопределяем и выводим для проверки в консоль:
name = 'Nastya'
console.log("Имя было изменено", name);
Или можно переопределить на другую переменную:
ageOfPerson2 = ageOfPerson1;

Определяем переменную const: 
const programmingLanguage = 'JavaScript';
Константа не переопределяется и выходит ошибка:
programmingLanguage = 'Java'
console.log(Java);
---------------------------------------------------------
В JS 8 типов данных:
- String (строка)
- Number - число
- Boolean - (логический) оперирует только trye/false
- Null - пустое значение или значение неизвестно 
- Undefined - переменная была объявлена, но значение ей не присвоено.
let x;
console.log(x);
(оставь этот вывод значения системе, используй null)
- Object - сложный тип данных, обьединяющий несколько параметров
const car = {
   name: "Toyota Corolla",
   year: 2017,
   isNew: false,
   owner: null
 }
//  Обратиться к свойсту Обьекта:
 console.log(car.name);
- Symbol - нужен для создания уникальных ключей обьекта (невозможно преобразовать в number)
const id = Symbol('id');
console.log(id);
- BigInt - большое число (больше, чем (2⁵³-1), т.е. 9007199254740991).
Для создания переменной этого типа нужно поставить букву n в конце числа: 
let bigNumber = 123456789n;

Как определить тип данных? (например что это строка)
typeof('') или typeof ''
console.log(typeof 'Maxim')
---------------------------------------------------------
// Явное преобразование к строке:
String(_переменная_)
const age = 22;
console.log('string age:', age, typeof String(age)); 

// Явное преобразование к числу:
Number(_переменная_)
'Hello' - выведет NaN (not a number)
'1 2' - выведет NaN (not a number)
let question2 = Number(prompt('Сколько будет 2 * 2?'))

// Явное преобразование к Boolean:
Большинство переменных выводится "true"
null, Undefined, NaN, 0, '' - выводится false ('' - пустая строчка)
'0' - строка, выдаст true
---------------------------------------------------------
// Конкатенация - объединение (например строк, строк строки, поиск нужных символов и фраз)
const name = 'Denis';
const specialization = 'Novice-developer';

// Конкатенация 3 способа:

const allInfo1 = name + ' ' + specialization;
console.log(allInfo1);

const allInfo2 = `${name} ${specialization}`
console.log(allInfo2);

let allInfo3 = name + ' ';
allInfo3 += specialization;
console.log(allInfo3);

"Hello".concat(" T", "p", "r", "o", "g", "e", "r"); // "Hello Tproger"
---------------------------------------------------------
// Узнать длинну строки (length)
const programmingLanguage = 'JavaScript';
console.log(programmingLanguage.length); // 10

// Получение индекса (буквы) строки
   Отсчет идет с 0
console.log(programmingLanguage[4]); // S
console.log(programmingLanguage[44]); // undefined
Или с помощью команды .charAt(0)
   С помощью этого НЕЛЬЗЯ поменять символ 
programmingLanguage[4] = 's'; (не сработает)
   Получаем последний символ
alert( str[str.length - 1] ); // o
---------------------------------------------------------
// toUpperCase, toLowerCase - изменяет на ЗАГЛАВНЫЕ и строчные 
const animal = 'Lion';
console.log('upper', animal.toUpperCase());
console.log('lower', animal.toLowerCase());
console.log(animal); - не изменяет само значение, а создает новое с заглавными или строчными

Слово с заглавной буквы:
const publication = "freeCodeCamp";
publication[0].toUpperCase() + publication.substring(1);

Слова с заглавной буквы:
const mySentence = "freeCodeCamp is an awesome resource";
const words = mySentence.split(" ");
words.map((word) => { 
    return word[0].toUpperCase() + word.substring(1); 
}).join(" ");
---------------------------------------------------------
// indexOf, includes - Найти символы 
   indexOf - найти и вывести индекс элемента
   includes - элемент есть/нет

const myText = 'Здесь должна была быть шутка, но я ее не придумал';
console.log('indexOf', myText.indexOf('о')); // 7
console.log('indexOf', myText.indexOf('шутка')); // 23
console.log('indexOf', myText.indexOf('членоногий')); // -1
console.log('includes', myText.includes('не придумал')); // true
---------------------------------------------------------
// slice, substring (одинаковы) - Если нужно получить символы между определенными индексами
const programmingLanguage1 = 'JavaScript';
console.log('slice', programmingLanguage1.slice(1, 5)); // avaS
console.log('slice', programmingLanguage1.substring(1, 5)); // avaS
---------------------------------------------------------
// replace, replaceAll - Замена (одного и всех)символов символов в строке.
const programmingLanguage2 = 'JavaScript';
console.log('replace', programmingLanguage2.replace('a', 'A')); 
console.log('replaceAll', programmingLanguage2.replaceAll('a', 'A')); 

Для замены несколько раз:
console.log(myInfoText.replaceAll('JavaScript', 'javascript').replaceAll('JS', 'js'));
---------------------------------------------------------
// trim() - удаление лишних пробелов
const nameOfUser = prompt('Ты кто?')
console.log('nameOfUser', nameOfUser.trim());
---------------------------------------------------------
console.log(- 5); // Унарный минус
console.log(10 - 5); // Бинарный минус

// Инкремент и Декримент
let cupsOfCoffe = 2;

cupsOfCoffe = + 5;
cupsOfCoffe += 1;
cupsOfCoffe = * 6; 
cupsOfCoffe = / 2; 
cupsOfCoffe *= 6;
cupsOfCoffe /= 2;
   
// Постфикc и префикс
let cupsCoffe = 0;

console.log('cupsCoffe++:', cupsCoffe++); // Возвращает исходное значение
   
console.log('++cupsCoffe:', ++cupsCoffe);
---------------------------------------------------------
//// Сравнение строк

// Операторы сравнения: 
> < >= <= == ===
Примечание: никогда в разработке веб-приложений не используй нестрогое сравнение ==. Оно является инициатором большого количества багов, так как производит преобразование типов. Используй исключительно строгое сравнение ===. Оно не преобразует типы и уменьшает шанс возникновения ошибок. 

console.log("'Ass' == 'ass'",'Ass' == 'ass'); // false
console.log('"A".charCodeAt()', 'A'.charCodeAt()); // 65
console.log('"a".charCodeAt()', 'a'.charCodeAt()); // 97

// String.fromCharCode() - Получитьв символ в обратную сторону из числа
console.log(String.fromCharCode(97)) // 'a'
console.log(String.fromCharCode(65)) // 'A

// == vs ===
// == сравнивает значения
console.log("'1' == 1", '1' == 1);
console.log("'200' > '21'", '200' > '21');
console.log("true == 1", true == 1);

// === сравнивает типы (рекомендовано)
console.log("1 === 1", 1 === 1)
console.log("true === 1", true === 1)
---------------------------------------------------------
// Math объект
console.log('Math объекты');
console.log('Число Pi', Math.PI); // 3.141592653589793

//// Округление

// Math.round() – простое округление
console.log('Простое округление:');
console.log('Math.round(40.4)', Math.round(40.4)); // 40
console.log('Math.round(40.5)', Math.round(40.5)); // 41
console.log('Math.round(40.6)', Math.round(40.6)); // 41

// Math.floor() – округление вниз
console.log('Округление вниз:');
console.log('Math.floor(40.5)', Math.floor(40.5)); // 40
console.log('Math.floor(40.9)', Math.floor(40.99)); // 40

// Math.ceil() – округление вверх
console.log('Округление вверх:');
console.log('Math.ceil(40.1)', Math.ceil(40.1)); // 41

// .toFixed(x) - обрезает значение
let result = Number((amount / rate).toFixed(2)); // .toFixed(2) - обрезает значение до 2х символов.
---------------------------------------------------------
//// Логические конструкции

if (если да, то)
else (что-то другое)
if else (если другое "да", то)
switch case (случай) - замена else & if
? : - замена else if

//// {if} {else}

if (условие) {
  // Выполнится, если условие будет истинным
} else {
  // Выполнится, если условие будет ложным
}

let isFrontendDeveloper = true;

if (isFrontendDeveloper) {
   console.log('isFrontendDeveloper = true','You are a Front-End developer. Welcome to the team!');
} else {
   console.log('isFrontendDeveloper = false', 'You are not a Front-End developer');
}

const condition = 5 > 10; // вернет false
if (condition) {
  console.log('Выражение истино!');
} else {
  console.log('Выражение ложно!');
}
Вывод: Выражение ложно!

let developerJobType = 'Front-End';

if (developerJobType === 'Front-End') {
   console.log('2000$');
} else if (developerJobType === 'Back-End') {
   console.log('1500$');
} else if (developerJobType === 'Full-Stack') {
   console.log('3500$');
} else {
   console.log('Зарплата не определена');

---------------------------------------------------------
//// switch case / break / default - замена else if

let developerJobType = 'Front-End';

switch (developerJobType) {
   case 'Front-End':
      console.log('2000$');
      break;
   case 'Back-End':
      console.log('1500$');
      break;
   case 'Full-Stack':
      console.log('3500$');
      break;
   default:
      console.log('Зарплата не определена');
---------------------------------------------------------
//// ? : - замена else if

let favoriteDrink = '???'

let message = favoriteDrink === 'Coffe' // условие 
   ? 'Your favorite drink is coffe' 
   // после '?' выполняет если условие 'true'
   : 'You most likely have a healthy CNS'; 
   // после ':' выполняет если условие 'false'

let question2 = prompt ('Сколько будет 2 * 2?') 
    question2 = Number(question2)

   question2 === 2 * 2
   ? alert('Ответ Верный') + correctAnswers++
   : alert('Ответ Неверный') + incorrectAnswers++;

// ? :
// ? if
// : else

console.log('message:', message);
---------------------------------------------------------
// && (И) - Ищет и выводит значение с "false". Значения  "true" пропускаются.
// || (ИЛИ) - Ищет и выводит значение с "true". Значения  "false" пропускаются.
// ! (НЕ)
// ?? (Оператор обьединения с null) - Пропускает только значения "null" и "undefined" 

//// && (И) - Ищет и выводит значение с "false". Значения  "true" пропускаются.
Пропускает алгоритм далее если оба значения true:
if (existingUserLogin === userLogin && existingUserPassword === userPassword) {
  alert(`Добро пожаловать, ${userLogin}!`);
} else {
  alert("Логин и (или) Пароль введены неверно!");
}

console.log('//&& (И)//');

let userAge = 20;

if (userAge > 6 && userAge <= 18) {
   console.log('Пользователь ходит в школу');
} else {
   console.log('Пользователь НЕ ходит в школу');
}


let programingLanguage = 'JavaScript'
let experienceInYear = 1;

if (programingLanguage === 'JavaScript' && experienceInYear >= 1) {
   console.log('Добро пожаловать в нашу команду');
} else {
   console.log('Нужно бооольше опыта');
}

//// || (ИЛИ) - Ищет и выводит значение с "true". Значения  "false" пропускаются.

let currentHour = 10;

if (currentHour < 8 || currentHour > 20) {
   console.log('Наш офис Закрыт');
} else {
   console.log('Наш офис Открыт');
}


let userNickname = null;
let defaultNicname = 'User';

let nickname = userNickname || defaultNicname || 'noname';
console.log('nickname', nickname);

//// ! (НЕ)
let = answer = prompt ('How old are you?')
answer = Number(answer);

if (!answer) {
   alert('Enter your total number of years')
} else {
   alert(`You are ${answer} years old`)
}

Предположим, у нас есть сайт и мы хотим сделать какие-то действия, если пользователь не авторизован. Также у нас есть переменная isAuth:
let isAuth = false; //if (existingUserPassword === userPassword) {
   alert (`Добро пожаловать, ${userPassword}`)
} Пользователь не авторизован

if (!isAuth) {
  // Пользователь не авторизован, условие выполнится
}
Условие сработает, так как !isAuth === true и в if будет передано true. 

//// ?? (Оператор обьединения с null)

// ?? - undefined, null 
console.log(false ?? 'Hello worldblat!');

// || - false, 0, "", NaN, indefined, null
console.log(false || 'Hello worldblat!');

---------------------------------------------------------
//// Циклы 
---------------------------------------------------------
// Переменные в циклах не видны за их пределами. 
// Чтобы переменные были видны ни только в цикле о и за ним, неоюходимо создать этупеременную заранее.

//// for () {}

// for (начальное значение; условие (до тех пор пока); шаг) {
   ... тело цикла ...
}

   for (let x = 0; x <= 10; x += 1) {
      console.log('x = ', x);
   }

   for (let value = 10; value >= 0; value -= 1) {
      console.log('value = ', value);
   }

   for (let i = 0; i < 3; i += 1) {
      let newStudent = prompt("Введите имя нового студента!");
      if (newStudent) {
      newStudent = newStudent.trim();
      alert(`Добро пожаловать, ${newStudent}!`);
      }
   } // Будет повторять вывод тела функции (Вопрос об имени, Приветствие + Имя)  3 итерации, до тех пор пока (i < 3)

   let sequence = [1, 1, 2, 3, 5, 8, 13];
   for (let i = 0; i < sequence.length; i++) {
   console.log(sequence[i]);
   } 
   // 1, 1, 2, 3, 5, 8, 13
   // Цикл выводит следующее значение в консоль по порядку, тк указано sequence[i]. sequence с индексом [i] на начальном этапе подразумевает что i = 0 (тк отсчет указан с 0), а даной цифре отсчета соотвествует индекс массива [0], в данном случае индекс массива sequence[0] = 1. А тк i++, цикл движется дальше на +1 ход вперед к следующему индексу массива.

// function calculateFlights (distance, isBusinessClass, milesTarget) {
      // body //
   };
   
   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   let flightsVariant1 = calculateFlights(3118, true, targets[i]);
   let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   for (let i = 0; i < targets.length; i++) {
      flightsVariant1();
      flightsVariant2(); 

   // Так не сработает! "ReferenceError: i is not defined". 
   // flightsVariant1/2 - как не знал до этого так и не знает что за значение "i"."i" становится известно лишь после обьявления цикла.

   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   for (let i = 0; i < targets.length; i++) {
      let flightsVariant1 = calculateFlights(3118, true, targets[i]);
      let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   // Так сработает!

---------------------------------------------------------
//// Замена for (без возможности использовать инедекс i)

const userNames = ['petya', 'vasya', 'evgeny'];

// name на каждой итерации свой собственный (локальный), поэтому используется const
for (const name of userNames) {
  console.log(name);
}
   // => "petya"
   // => "vasya"
   // => "evgeny"

---------------------------------------------------------
//// while - сначала думает (смотрит условие), потом делает
console.log('//while//');

// while (условие) {}

   let i = 0;
   while (i < 10) {
      console.log('i = ', i);
      i += 1;
   }

---------------------------------------------------------
//// do while - сначала делает, потом думает (смотрит условие)

   let i = 0;
   do {
      i += 1
      console.log('i = ', i);
   } while (i <= 5) // Выдаст 6, начав с 1 (тк сначала делает, а потом проверяет. Важна последовательность)

   let i2 = 0;
   do {
      console.log('i2 = ', i2);
      i2 += 1
   } while (i2 <= 5) // Выдаст 5, начав с 0 

---------------------------------------------------------
//// break 

   let z = 0;
   while (z < 10) {
   console.log(z);
   if (z === 3) break;
   z++;
   }
Остановится на 3х. Выведет: 0 1 2 3

---------------------------------------------------------
//// continue 

   for (let f = 0; f <= 5; f++) {
      if (f === 2) continue;
      console.log(f);
   }
Пропустит 2. Выведет: 0 1 3 4

---------------------------------------------------------
//// Массив - это набор элементов

let target = [
   {nameTown:'Saskatoon', km: 3000}, 
   {nameTown:'Asuncion', km: 7000}, 
   {nameTown:'Tokio', km: 15000}
   ];

   for (let i = 0; i < target.length; i++) {
      const el = target[i];
      console.log(`Town name: ${el.nameTown} km: ${el.km}`);
   }
//Or
   target.forEach(el => console.log(el.nameTown)); // Saskatoon Asuncion Tokio
   target.forEach(el => console.log(el.km)); // 3000 7000 15000


 
let fruits = ["Яблоко", "Апельсин", "Слива"];
   alert( fruits[0] ); // Яблоко
   alert( fruits[1] ); // Апельсин
   alert( fruits[2] ); // Слива


let numbers = [0, 0, 0, 0, 1];
let sum = 0;

for (let i = 0; i < numbers.length; i += 1) {

   numbers[i] = numbers[i] + 2; 
   // При каждом проходе цикла прибавляет к "i" +1, что пошагово продвигает цикл по элементам [ ] массива "numbers".
   Будет получаться:
   numbers = [2, 0, 0, 0, 1]; - 1й проход цикла
   numbers = [2, 2, 0, 0, 1]; - 2й проход цикла
   numbers = [2, 2, 2, 0, 1]; - 3й проход цикла
   numbers = [2, 2, 2, 2, 1]; - 4й проход цикла
   numbers = [2, 2, 2, 2, 3]; - 5й проход цикла

   sum = sum + numbers[i];
   // Складывает к переменной "sum" актуальное значение массива (в зависимости на какой позиции сейчас находится цикл)
   sum = 0 + 2 = 2
   sum = 2 + 2 = 4
   sum = 4 + 2 = 6
   sum = 6 + 2 = 8
   sum = 8 + 2 = 11
}
console.log(sum); // 11

// Выявить min / max значение из массива:

   let arr = [22,4,7];
   console.log(Math.min(...arr));

// разные типы значений
   let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

   получить элемент с индексом 1 (объект) и затем показать его свойство
   alert( arr[1].name ); // Джон

   получить элемент с индексом 3 (функция) и выполнить её
   arr[3](); // привет

// let cities = [
   {Valencia: 3118}, 
   {Lisbon: 3617}, 
   {Saskatoon: 3000}, 
   {Asuncion: 7000}
   ];

(cities[0].Valencia); // 3118
(cities[0]); // { Valencia: 3118 }
---------------------------------------------------------
// array.forEach()

Метод используется для перебора массива.

   arr.forEach(function callback(item, index, array)){
      ... делать что-то с item
      }); 

Он для каждого элемента массива вызывает функцию callback.
Этой функции он передаёт три параметра callback(item, i, array):
    item – очередной элемент массива.
    i – его номер.
    array – массив, который перебирается.

Например, этот код выведет на экран каждый элемент массива:
   ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
 // Вызов alert для каждого элемента

А этот вдобавок расскажет и о своей позиции в массиве:
   ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
   alert(`${item} имеет позицию ${index} в ${array}`);
   });

///  arr = [
      {name:'Saskatoon', value: 3000}, 
      {name:'Asuncion', value: 7000}, 
      {name:'Tokio', value: 15000}
   ];

   arr.forEach(el => console.log(el.name));
   arr.forEach(el => console.log(el.value));

---------------------------------------------------------
// Array.length - число элементов этого массива

let items = ['shoes', 'shirts', 'socks', 'sweaters'];
console.log(items.length); // 4
---------------------------------------------------------
//// Функции 
     С помощью них предотвращают дублирование кода. 
     Функция вызывается добавлением () после нее
   
В функцию мы можем передавать параметры (любые типы данных). Одним из параметров может быть другая функция (например callback, alert, console.log) 

// Function Declaration - обьявление функции
   (Можем вызывать функцию до ее определения)
   
   function name(param) {}

   function sum0 (a = 1, b = 3) {
      console.log(a + b);
   }
   sum0(); // 4
// Or
   function sum1 (a, b) {
      console.log(a + b);
   }
   sum1(1, 3); // 4
// Or
   function sum2 (a, b = 3) {
      console.log(a + b);
   }
   sum2(1); // 4
---------------------------------------------------------
//// Callback — это функция, в основной функции, которая должна быть выполнена после того, как другая (вторая) функция завершила выполнение (отсюда и название: callback — функция обратного вызова).

   function sum03(a, b, callback) {
   const result = a + b;
   callback(result);
   }

   function displayer(res) {
      console.log('Результат:', res);
   }

   sum03(3, 10, displayer);

/* Что тут происходит?
Создаем функцию sum03 с параметрами 'a', 'b', 'callback' 
(параметрами могут быть любые данные, даже функции, как и callback в данном случае.)
'callback' - это лишь произвольное название функции (хотя тут больше похоже на переменную со значением, чем на функцию. Но так как callback принимает значение от функции - это функция), в которую мы далее будем передавать полноценную функцию со значениями displayer. 

Создаем переменную result которая выполняет сложение двух неизвестных переменных 'a' и 'b' (пока их значение undefined)

Назначаем что функция callback будет иметь и выводить параметр result который хранит результат сложения.

Далее создаем функцию с наименованием displayer.
(которая в дальнейшем будет назначена передавать свое значение в callback. По сути можно сказать что callback = displayer)

Функция displayer имеет параметр res.
Далее тело функции displayer будет выводить в консоле строку 'Результат:' и переменную res (которую перенимает значения из result)

Далее самое важное. Мы передаем (назначаем) наши параметры функции sum 
Теперь (a, b, callback) = (3, 10, displayer)
a = 3
b = 10
callback = функция displayer

Грубо говоря, общая картина такова, что сумма значений 
(a + b) = result
result = callback 
callback = displayer
А так как displayer передает значения в callback, а callback хранит в себе значение переменной result, то есть сумму (a + b), то для функции displayer нам необходимо сохранить это значение в переменную res.

3 + 10 = 13. Помещается в функцию (параметр) callback и храниться в переменной result в качестве параметра.
А наш параметр callback является функцией displayer которая так же хранит в себе аналогичную переменню res в качестве параметра.

Получается displayer это отражение callback, которая хранит в себе все ее значения с небольшими дополненеиями. Которая могла бы вызываться по необходимости (в конце), то есть отдельно от выполнения главноего тела функции sum, где участвует callback.
*/

// Или это же, но через анонимную функцию (без названия)

   function sum04(a, b, anon_function) {
      const result = a + b;
      anon_function(result);
   }

   sum04(5, 10, function(res01) {
      console.log('Результат:', res01);
   });

// callback с уже существующими функциями 

   function sum05(a, b, alert) {
      const result = a + b;
      alert('Результат: ' + result);
   }

   sum05(5, 11, alert)
   
---------------------------------------------------------
//// Return - позволяет вернуть результат(значение) из функции 
*return - останавливает выполнение функции

// let increaseByTwo = function (number) {
      let sum = 2 + number;
      return sum;
   };

   increaseByTwo(1); // Функция вернёт 3
   increaseByTwo(2); // Функция вернёт 4

Чтобы функция вернула значение, мы используем оператор return. После оператора указываем, что именно надо вернуть. В нашем случае значение переменной sum. Когда программа доходит до строки с return, функция отдаёт результат своей работы и выполнение кода из тела функции останавливается, иными словами происходит выход из функции.

Несколько вещей, которые нужно знать:

   -Код, написанный на новой строке после return, не выполняется.
   -Функция не может вернуть сразу много значений, она возвращает только один результат.
   -Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, ничего.

---------------------------------------------------------
Обрати внимание на разницу между параметрами и аргументами. На практике зачастую эти слова взаимозаменяемы, но стоит понимать отличия:

    Параметр — это название переменной, которое указывается в объявлении функции. Они используются для многоразовости функции, для подставления в нее разных аргументов на место ярлыков(параметров). (price, count)
    Аргумент — это значение параметра, которое передается при вызове функции. (100, 5)

   function showTotalPrice(price, count) {
   console.log(price * count);
   };
   Данная функция имеет два параметра — цена (price) и количество (count). По сути это переменные, которым присваиваются значения при вызове функции.

   showTotalPrice(100, 5); // Выведет в консоль: 500
   showTotalPrice(350, 2); // Выведет в консоль: 700
   // Аргументы (100, 5)

   
---------------------------------------------------------

// document.querySelector('.селектор') - найти элемент
   console.log(document.querySelector('.селектор')) - удостовериться, что найден нужный элемент

// .classList.remove - удалить класс
   document.querySelector('.page').classList.remove('light-theme') - удалить класс в найденном селекторе

// .classList.add('dark-theme') - добавить класс
   document.querySelector('.page').classList.add('dark-theme');  - добавить класс в найденном селекторе 

Но это некорректная запись. Для нормализации читабельности, скорости и удобства кода назначим переменной значение поиска, чтобы не искать ее каждый раз.

   let page = document.querySelector('.page');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
   
///

   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
   };

'onclick' свойство (по клику) - это событие для браузера 

Данная конструкция создает переменную которая будет хранить в себе найденный класс с кнопкой для смены темы сайта.
При нажатии на кнопку будет запущенна функция удаления светлой темы и добавления темной.

// .classList.toggle - чередование переключения классов.
Удаляет(remove) если есть, добавляет(add) если нет.

   селектор.classList.toggle('класс');
   page.classList.toggle('light-theme');

Итого код для переключения темы:
   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.toggle('light-theme');
   page.classList.toggle('dark-theme');
   };

---------------------------------------------------------
// .textContent - выводит именно текст класса или селектора, а не код вместе с текстом

   let message = document.querySelector('.subscription-message');
   console.log(message.textContent);

С помощью .textContent можно переназначить текст
message.textContent = 'Измененный текст'
---------------------------------------------------------
'onsubmit' свойство - триггер на событие отправки формы (не кнопки!)

   let message = document.querySelector('.subscription-message');
   let form = document.querySelector('.subscription');

   form.onsubmit = function(evt) {
   // Инструкция ниже отменяет отправку данных
   evt.preventDefault();
   message.textContent = 'Форма отправлена!';
   };

---------------------------------------------------------
Отличия Function Declaration и Function Expression в том 
что FD мы можем вызывать до определения функции, а FE нет
---------------------------------------------------------
//// Рефакторинг 

Разработчики рефакторят свой код для того, чтобы он был понятен коллегам и самому автору через какое-то время, легко поддерживался, не содержал в себе повторов, огромных сложных конструкций и так далее. Здесь, как в школе: сначала пишем в черновик, пробуем, зачёркиваем, пробуем снова, пока не придём к решению, а потом аккуратно выводим в чистовик.

При этом рефакторингом занимаются все, даже самые крутые рок-звёзды из мира разработки.
---------------------------------------------------------
 Хороший код всегда состоит из множества частей, каждая из которых занимается только своей задачей.
---------------------------------------------------------
//// Arrow Function Expression
// Символ "=>" заменяет термин "function"

   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   };
   let result = sum(3.14, 3.14);
   console.log('Result:', result);

// Создаем имя функции "sum", вводим в () параметры, с помощью => обозначаем что это стрелочная функция которая переходит к телу {}. После "=>" без указания "{}", дальнейший текст будет воспринят как для команды "return".

   const sayHello = () => {
      alert("Hello");
   };

   const sayHello = (name) => {
      alert(`Hello, ${name}`);
   };  

const sayHello = name => alert(`Hello, ${name}`);
const calc = (a, b) => a + b;

sayHello("Vasya"); // Выведет сообщение "Hello, Vasya"
console.log(calc(1, 2)) // Выведет в консоль: 3

   let sum = function (a, b) {
      return a + b
   } 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   }

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => a + b; 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
   // Только если функция состоит из 1 строчки

---------------------------------------------------------
//// Использование Arrow Function как callback

   function multiply (a, b, callback) {
      const result = a * b;
      callback(result);
   }

   multiply(5, 2, (multiplyResult) => {
      console.log('multiplyResult:', multiplyResult);
   });

---------------------------------------------------------
//// Замыкания - функция внутри функции

// Замыкания — это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.
// Свободные переменные — это переменные, которые не объявлены локально и не передаются в качестве параметра.

   let numberGenerator = function() {
// Локальная переменная, которая доступна только в замыкании
   var num = 1;
   function checkNumber() {
      console.log(num);
   }
   num++;
   return checkNumber;
   }

   var number = numberGenerator();
   number(); // 2

В примере функция numberGenerator создаёт локальную «свободную» переменную num (число) и checkNumber (функция, которая выводит число в консоль). 
Функция checkNumber не содержит собственной локальной переменной, но благодаря замыканию она имеет доступ к переменным внутри внешней функции, numberGenerator. 
Поэтому объявленная в numberGenerator переменная num будет успешно выведена в консоль, даже после того, как numberGenerator вернёт результат выполнения.

Если посмотреть Debuger, то clg функции checkNumber будет выполняться последним. Почему? Тк идет передача этой функции в главную, с помощью return. А при вызове главной функции number(), следовательно и вызывается clg функции checkNumber.

-------------Разбор примера-------------
const createCounter = (initialValue = 0) => {
   return (valueToAdd) => {
      return initialValue + valueToAdd
   };
};

const addFive = createCounter(5);
const result = addFive(7);
console.log(result);

// Смотрим процесс черз Debuger. До момента с назначением аргумента (5) функции createCounter все понятно. Далее это значение с параметром, упаковывается в переменную addFive. 
После, уже нынешняя переменная addFive(тобишь createCounter(5)) двигается далее и встречает return(1*), который возвращает в наш addFive вложенную анонимную функцию(со всеми ее значеними). 
То есть, теперь наш addFive != createCounter(5)
А имеет значение addFive = (valueToAdd) => {
      return initialValue + valueToAdd
   };
Это Debuger обработал первый(1*) return.
После процесс Debuger видит новый аргумент addFive(7)и переключается на него, одновременно упаковывая эти значения в переменную result.
И теперь самый важный момент. 
Параметр addFive стал (7). Но тут важно не ошибиться, addFive != исходному createCounter(5)
addFive имеет значение стрелочной функции с параметром (valueToAdd).
Поэтому при обьявлении addFive(7), меняется параметр (valueToAdd). А дальше уже все понятно. Этот параметр используется в return для возврата initialValue + valueToAdd. 
Которые в итоге возвращаются в их анонимную стрелочную функцию которая = переменой addFive, которая уже ныне = переменой result, которая в последствии и выводится в консоль.

   createCounter = (initialValue = 0) => {
      let counter = initialValue;

      return (valueToAdd) => {
         counter += valueToAdd;
         return counter;
      };
   };

   const addTwo = createCounter(2);
   result = addTwo(10); // 12
   result = addTwo(5);
   result = addTwo(3);
   console.log(result);

---------------------------------------------------------
//// Область видимости переменных

/// Глобальная область видимости
Позволяет переменной быть видимой из любой точки кода. Переменная считается глобальной, когда она объявлена вне функций и блоков:
const x = 10; // Глобальная переменная

   function show() {
   console.log(x); // Выведет 10
   }

/// Локальная область видимости (3 вида):
// Блочная -
Область видимости ограничена блоком кода (т.е. фигурными скобками { и }):

   if (true) {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined
   / Переменная x будет доступна только внутри блока if

   // Исключение — var. Они не имеют блочной области видимости и доступны даже вне блока.

// Область видимости функции -
Ограничена функцией, в которой объявлена переменная (Аналогично блочному)

   function test() {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined

// Модульная — область видимости ограничена модулем.

---------------------------------------------------------
/// Алгоритм поиска переменных движком JS

   const x = 10;

   function show() {
   const y = 20;

   if (true) {
      const z = 30;
      console.log(x + y + z);
   }
   }
   show(); // Выведет в консоль 60   

В данном примере функция show() выводит в консоль сумму трёх переменных. При обращении к переменной x, движок JavaScript действует по такому алгоритму:

    Пытается найти переменную с именем x внутри блока if. Не найдя её, переходит к родительскому блоку наверх.
    Пытается найти переменную x в функции show(). Не найдя её, переходит к глобальному контексту.
    Находит глобальную переменную x и использует её значение.
    
   / Поиск происходит изнутри наружу. От локальных (точка отправления) к более глобальным

// При этом, если во внутреннем блоке уже найдена переменная с нужным именем, поиск останавливается:
   const x = 10;
   
   if (true) {
   const x = 20;
   console.log(x); // Выведет 20
   }
   console.log(x); // Выведет 10

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------









