<br/> - разрыв строки (Shift+Enter)
<p></p> - параграф, абзац (Enter)
<hr/> - горизонтальная линия (horizontal rule)
<span></span> - строчный элемент (выделяет выделенную строку без переноса)
<b> - Жирный текст
<strong> - Важный текст
font-weight: bold;
<i> - текст Курсив (наклонный)
<em> - текст Акцентирует внимание (наклонный)
<mark> - Маркированный текст
<small> - Небольшой текст
<del> - Удаленный (зачеркнутый) текст
<ins> - Вставленный (добавить) текст
<sub> - Подстрочный текст
<sup> - Надстрочный текст

<p contenteditable="true"> - делает параграф редактируемым

lorem20 - набор рыбьего текста 

<a href="">Наименование ссылки</a> - ссылка 
<a href="" target="_blank"> </a> - ссылка в новой вкладке
<img src="" alt=""> - тег для вставки URL или локального пути изображения. "alt" используется для написания текстового объяснения, в случае если фото будет недоступно
<_ target="_blank"> - открытие в новой вкладке
<a href="https://webref.ru"><img src="image/shark.jpg" alt=""></a> - ссылка в изображении

<ol></ol> - упорядоченная оболочка для пунктов списка
<ul></ul> - неупорядоченный, dots список 
<ol/<ul type="I/square"> Для изменения нумерации используют "type" 
<li></li> - сам список (пишется внутри <ul></ul> или <ol></ol>)

<li value="3"> -ставит значение 3 для нумерации строки
style= "list-style-type: disc/circle/square/decimal/georgian/trad-chinese-informal/kannada; "

ul>li{Элемент $}*5 - Появится 5 строк с наименованием "Элемент".При добавлении "$", появится нумерация   

<table></table> - оболочка для тегов таблицы
<thead></thead> - заголовок таблицы (столбцы именуются как <th></th>, а не как <td></td>)
<tr></tr> - строка таблицы (table rool)
<th></th> - столбцы заголовка таблицы
<tbody></tbody> - основное тело таблицы
<tr></tr> - строка таблицы (table rool)
<td></td> - столбцы в теле таблицы (внутри тега <tr></tr>) (table data)

<form></form> - поле для ввода
<label for="логин">Логин</label> -  текст перед полем ввода. Тег "for" связывается с тегом "id" и при нажатии на текст выделяется форма.
<input type="text/password/email/number/range/date/color/message/" id="логин"> - что будет вводиться в поле ввода.

<section id="sex">
    <option value="Мужчина">м</option>
    <option value="Женщина">ж</option>
</section> - выпадающий из прошлого список

<value=""> - атрибут тега, определяет что будет написано
<id=""> и <class=""> - "id" не должно повторяться, "class" может и используется для стилистики
<div></div> - блочный элемент (выделяет и переносит абзацом)
<header>/<footer>/<nav>/<article>/<section (группа для article)>/<aside (для меню слева-справа)> - это все замена <div> для правильной индексации и нормализации поиска сайта

<figure>
   <img src="" alt="">
   <figcaption>Подпись</figcaption> - связывает подпись с картинкой
</figure> 
<details>
   <summary></summary> - Описание и краткое заглавие выпадающего описания
</details>

_______________________________
CSS
   h1       {color: red}
-селектор {свойство: значение}
-cвойство: функции (значение);
.class > p - обращение только к детям класса (не учитывая детей детей)
---------------------------------------------------------
font-family - выбор шрифта (Roboto,Times..)
font-size - размер текста
font-weight - толщина начертание шрифта (аналог <strong>)
text-transform: uppercase - заглавный шрифт
---------------------------------------------------------
width= "150" - устанавливает ширину элемента (ширину области)
word-spacing - расстояние между словами
letter-spacing - расстояние между символами
line-height - межстрочный интервал
text-decoration: underline; - подчеркивания, зачеркивания, none
<del></del> -зачеркнутый текст или (представляет диапазон текста, который был удалён из документа)
<ins></ins> - подчеркивание или (показывает что было добавлено в код)
opacity: 0.4 - непрозрачность элемента
---------------------------------------------------------
#ff0000 - красный; color: #00ff00 зеленый; color: #00ff00 синий;
color: rgba(0, 255, 0, 0.2) - цвета и прозрачность
-Дизайн цвета можно копировать с браузера с помощью пипетки из "Исследовать элемент"
---------------------------------------------------------
-CSS код можно писать как в  HTML в <head><style></style></head>
 Можно писать инлайн <header style="color: black;"></header>
 Можно писать так же отдельно в css файле: <link rel="stylesheet" href="Index.css0">
---------------------------------------------------------
padding: 0px 20px 0px 20px - можно написать сразу для 4х сторон. Отсчёт идёт по часовой стрелке.
padding - внутренние отступы (внутри рамки)
margine - внешние отступы (за рамкой)
margin: auto; - выравнивание по центру 
bottom - подвал/низ
top - верх
---------------------------------------------------------
* {} - селектор задает значение всему на странице
#id {} - стилизация через ID: #id {}
.card p {} -для обращения к безликому(повторяющемуся в др местах) дочернему тегу через родительский указываем путь: .card p {}
@import url() - Импорт шрифта
div p - выбор всех элементов p внутри элемента div
---------------------------------------------------------
filter: blur(2px)
filter: grayscale (0%) - сепия
filter: opacity (100%) - непрозрачность
filter: saturate (100%) - насыщенность 
filter: contrast (100%) - контрастность
background: linear-gradient ( 45deg, blue, lightGreen) - градиент
cursor:pointer; - изменение курсора при наведении
---------------------------------------------------------
background-image: url("img/whistle.svg"); - выставление бэкграунд фото
background-repeat: no-repeat; - не размазывать фон (иконки) по всему блоку
background-position: center top; - местоположение бэкграунд изображения (может выступать иконкой, а не фоном сайта)
background-position: right 35% bottom 45%;
background-size: - размер изображения
---------------------------------------------------------
list-style: none или url('/media/examples/rocket.svg'); - что будет показываться в пунктах(точках) списка
---------------------------------------------------------
.cards a:hover {} - интерактивность при наведении на элемент, меняет цвет/размер шрифта итд 
transition: all .2s; - анимация увеличения для селектора (например для ссылки при наведении)
.table:nth-child(odd/even/1/2/3..) - выделение столбцов таблицы
---------------------------------------------------------
Flex
---------------------------------------------------------
Используется для родительского элемента:
<div class="container"><div></div></div>

display: flex; - создаёт флекс контейнер 
flex-direction: row/column; - элементы в строку/ в колонке

.container { justify-content: center; } - установка элемента по центру
justify-content: space-around; - равномерное распределение элементов по контейнеру (space-around/space-between/center/start/end)
---------------------------------------------------------
_______________________________
JavaScript 
JS - регистрозависимый язык
---------------------------------------------------------
Функция isNaN() возвращает true, если значение не число, равно NaN (Not-a-Number), и false, если нет.
---------------------------------------------------------
== 	равно
=== 	равное значение и равный тип
!= 	не равный
---------------------------------------------------------
unshift - Добавление новых элементов в начало массива
var fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];
fruits.unshift("Lemon","Pineapple");
---------------------------------------------------------
Math.max([x[, y[, …]]])- Возвращает наибольшее число из своих аргументов.
---------------------------------------------------------
//// Циклы
---------------------------------------------------------
// Будь внимателен в Циклах и Массивах
* со знаками <= >= < > 
* с Мутациями массива
-------------------
Если не сходится счет цикла с индексами массива, то возможно дело в знаках или в slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end). 
Дело может быть так же в методах массивов: С мутацией или без 

// Вот пример когда создание переменной с хранением в ней длинны массива может помочь избежать неправильного подсчета итераций и индексов при мутации массива с использованием на примере shift(). 

const peopleWaiting = [
   "Кристина",
   "Олег",
   "Кирилл",
   "Мария",
   "Светлана",
   "Артем",
   "Глеб"
];

let numberGotParcel = peopleWaiting.length;

for (let i = 0; i < numberGotParcel; i++) {
   console.log('numberGotParcel', numberGotParcel); // 7
   console.log('peopleWaiting.length', peopleWaiting.length); // 7 => 1

   const visitorLeaveName = peopleWaiting.shift();
   console.log(`${visitorLeaveName} получил(а) посылку. В очереди осталось ${peopleWaiting.length} человек`);
};

-------------------
for (начало; условие; шаг) {
  // ... тело цикла ...
}
for (let i = 0; i < 3; i++) { 
   // выведет 0, затем 1, затем 2
  alert(i);
}
---------------------------------------------------------
Чтобы вывести объединить текстовую строку и переменную является знак «+». Чтобы сообщить о том, что здесь закончился текст и начинается переменная Javascript, нужно открыть и закрыть кавычки.
alert( "Привет " + name + "!");
---------------------------------------------------------
<script defer src="js/vendor/jquery.js"></script>
async - выполнение скриптов по мере возможности, "рандомно"
defer - выполнение в строгой последовательности их размещения
---------------------------------------------------------
Math.floor() - округление вниз. Округляет аргумент до ближайшего меньшего целого.
---------------------------------------------------------
querySelector - "найди и принеси элемент" селектор запросов (en/ru)
document.querySelector('селектор');
document.querySelector('.page'); - js ищет на странице элемент с классом "page"
---------------------------------------------------------
Для добавления js в html, <script></script> добавляется перед </body>
Для подключения js к html необходимо ввести в конце <body> <script src="index.js"></script> </body>
---------------------------------------------------------
Тестирование с помощью консоли (вывод в консоль):
console.log(document.querySelector('.page'));
console.log - обращение к консоли
(document. ___ ) - "документ" поиск по данному файлу 
---------------------------------------------------------
classList.remove - удаление класса 
элемент.classList.remove('класс');
document.querySelector('.page').classList.remove('light-theme');
Сначала ищем селектор, во втором моменте "." не ставится, тк js знает что это класс
---------------------------------------------------------
classList.add - добавление класса 
элемент.classList.add('класс');
---------------------------------------------------------
Переменная — это способ сохранить данные, дав им понятное название (ярлык с файлами).
Константа - почти тоже самое что и переменная, только значение которой нельзя менять
---------------------------------------------------------
let - с помощью него можно создать (обьявить) переменную. 
let: - "пусть/допустим" за которым следует имя для вашей переменной. 
Чтобы задать несколько значений let 
let numbers = [10, 4, 100, -5, 54, 2]; - массив

У переменных после их наименования с помощью "let" должно быть присвоено значение.
" = " - с помощью знака равенства присваиваем значение переменной
let variableName = 'Я значение переменной!';

let header = document.querySelector('header'); - при вводе переменной "header", JS выполняет функцию поиска по документу селектора header
---------------------------------------------------------
Условия / условные выравнивания (Conditionals) - it/else/else if 
---------------------------------------------------------
События (Events) - это действия, которые происходят в браузере, например, нажатие кнопки или загрузка страницы или воспроизведение видео, в ответ на которые мы можем запускать блоки кода.
Конструкции прослушивающие события - прослушиватели событий
Блоки кода выполняемы в ответ на срабатывание события - обработчики событий
---------------------------------------------------------
Циклы (Loops)

for - для / of - из

const fruits = ['apples', 'bananas', 'cherries'];
for (const fruit of fruits) {
  console.log(fruit);
}
Данный цикл будет поочередно выводить значения массива константы "fruits"
Строка for (const fruit of fruits) говорит:
1.Получи первый элемент из fruits.
2.Установи переменную fruit для этого элемента, затем запусти код между скобками {}.
3.Получи следующий элемент из fruits и повторяй, пока не дойдешь до конца.
---------------------------------------------------------
Массив — это набор элементов
Строка const fruit = ['apples', 'bananas', 'cherries']; создает массив.
---------------------------------------------------------
focus() - 
guessField.focus(); помещает курсор в текстовое поле при загрузки страницы 
---------------------------------------------------------
alert() - выводит модальное окно на странице
const years = prompt('Сколько вам лет?', 100);
alert('Вам ' + years + ' лет!')

prompt() - выводит окно с строкой заполнения и его возможным заполнением('Наименование окна','Запись в строке заполнения') 
Сохранить в переменную: const userName = prompt('Как вас зовут?');

confirm() - диалоговое окно с сообщением и кнопками выбора "cancel" - false, "ok" - true.
---------------------------------------------------------
Чтобы вывести в консоль в одну строку несолько параметров:
console.log(`${myInfoText[0]} ${myInfoText[441]}`)
---------------------------------------------------------
Определяем переменную let: 
let name = 'Petr the pig';
Переопределяем и выводим для проверки в консоль:
name = 'Nastya'
console.log("Имя было изменено", name);
Или можно переопределить на другую переменную:
ageOfPerson2 = ageOfPerson1;

Определяем переменную const: 
const programmingLanguage = 'JavaScript';
Константа не переопределяется и выходит ошибка:
programmingLanguage = 'Java'
console.log(Java);
---------------------------------------------------------
В JS 8 типов данных:
- String (строка)
- Number - число
- Boolean - (логический) оперирует только trye/false
- Null - пустое значение или значение неизвестно 
- Undefined - переменная была объявлена, но значение ей не присвоено.
let x;
console.log(x);
(оставь этот вывод значения системе, используй null)
- Object - сложный тип данных, объединяющий несколько параметров
const car = {
   name: "Toyota Corolla",
   year: 2017,
   isNew: false,
   owner: null
 }
//  Обратиться к свойству Объекта:
 console.log(car.name);
- Symbol - нужен для создания уникальных ключей объекта (невозможно преобразовать в number)
const id = Symbol('id');
console.log(id);
- BigInt - большое число (больше, чем (2⁵³-1), т.е. 9007199254740991).
Для создания переменной этого типа нужно поставить букву n в конце числа: 
let bigNumber = 123456789n;
---------------------------------------------------------
// Как определить тип данных? (например что это строка)
typeof('') или typeof ''
console.log(typeof 'Maxim')
// Проверка на тип значения = 'число'
   const value = 2   
   if (typeof value === 'number') {
      //it's a number
   }
---------------------------------------------------------
// Явное преобразование к строке:
String(_переменная_)
const age = 22;
console.log('string age:', age, typeof String(age)); 

// Явное преобразование к числу:
Number(_переменная_)
'Hello' - выведет NaN (not a number)
'1 2' - выведет NaN (not a number)
let question2 = Number(prompt('Сколько будет 2 * 2?'))

// Явное преобразование к Boolean:
Большинство переменных выводится "true"
null, Undefined, NaN, 0, '' - выводится false ('' - пустая строчка)
'0' - строка, выдаст true
---------------------------------------------------------
// Конкатенация - объединение (например строк, строк строки, поиск нужных символов и фраз)
const name = 'Denis';
const specialization = 'Novice-developer';

// Конкатенация 3 способа:

const allInfo1 = name + ' ' + specialization;
console.log(allInfo1);

const allInfo2 = `${name} ${specialization}`
console.log(allInfo2);

let allInfo3 = name + ' ';
allInfo3 += specialization;
console.log(allInfo3);

"Hello".concat(" T", "p", "r", "o", "g", "e", "r"); // "Hello Tproger"
---------------------------------------------------------
// Узнать длину строки (length)
const programmingLanguage = 'JavaScript';
console.log(programmingLanguage.length); // 10

// Получение индекса (буквы) строки
   Отсчет идет с 0
console.log(programmingLanguage[4]); // S
console.log(programmingLanguage[44]); // undefined
Или с помощью команды .charAt(0)
   С помощью этого НЕЛЬЗЯ поменять символ 
programmingLanguage[4] = 's'; (не сработает)
   Получаем последний символ
alert( str[str.length - 1] ); // o
---------------------------------------------------------
// toUpperCase, toLowerCase - изменяет на ЗАГЛАВНЫЕ и строчные 
   const animal = 'Lion';
   console.log('upper', animal.toUpperCase());
   console.log('lower', animal.toLowerCase());
   console.log(animal); - не изменяет само значение, а создает новое с заглавными или строчными

Слово с заглавной буквы:
   const publication = "freeCodeCamp";
   const FreeCodeCamp = publication[0].toUpperCase() + publication.substring(1);

   console.log('freeCodeCamp toUpperCase:', FreeCodeCamp);

Несколько слов с заглавной буквы:
   const mySentence = "freeCodeCamp is an awesome resource";
   const words = mySentence.split(" ");
   words.map((word) => { 
      return word[0].toUpperCase() + word.substring(1); 
   }).join(" ");
---------------------------------------------------------
// slice, substring (одинаковы) - Если нужно получить символы между определенными индексами
const programmingLanguage1 = 'JavaScript';
console.log('slice', programmingLanguage1.slice(1, 5)); // avaS
console.log('slice', programmingLanguage1.substring(1, 5)); // avaS
---------------------------------------------------------
// replace, replaceAll - Замена (одного и всех)символов символов в строке.
const programmingLanguage2 = 'JavaScript';
console.log('replace', programmingLanguage2.replace('a', 'A')); 
console.log('replaceAll', programmingLanguage2.replaceAll('a', 'A')); 

Для замены несколько раз:
console.log(myInfoText.replaceAll('JavaScript', 'javascript').replaceAll('JS', 'js'));
---------------------------------------------------------
// trim() - удаление лишних пробелов
const nameOfUser = prompt('Ты кто?')
console.log('nameOfUser', nameOfUser.trim());
---------------------------------------------------------
console.log(- 5); // Унарный минус
console.log(10 - 5); // Бинарный минус

// Инкремент и Декримент
let cupsOfCoffe = 2;

cupsOfCoffe = + 5;
cupsOfCoffe += 1;
cupsOfCoffe = * 6; 
cupsOfCoffe = / 2; 
cupsOfCoffe *= 6;
cupsOfCoffe /= 2;
   
// Постфикc и префикс
let cupsCoffe = 0;

console.log('cupsCoffe++:', cupsCoffe++); // Возвращает исходное значение
   
console.log('++cupsCoffe:', ++cupsCoffe);
---------------------------------------------------------
//// Математические операторы
   +, -, *, /, %, **

// Взятие остатка от деления %
a % b – это остаток от целочисленного деления a на b

   alert( 5 % 2 ); // 1, остаток от деления 5 на 2
   alert( 8 % 3 ); // 2, остаток от деления 8 на 3

// Возведение в степень **
В выражении a ** b оператор возведения в степень умножает a на само себя b раз.

alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)
---------------------------------------------------------
//// Сравнение строк

// Операторы сравнения: 
> < >= <= == ===
Примечание: никогда в разработке веб-приложений не используй нестрогое сравнение ==. Оно является инициатором большого количества багов, так как производит преобразование типов. Используй исключительно строгое сравнение ===. Оно не преобразует типы и уменьшает шанс возникновения ошибок. 

console.log("'Ass' == 'ass'",'Ass' == 'ass'); // false
console.log('"A".charCodeAt()', 'A'.charCodeAt()); // 65
console.log('"a".charCodeAt()', 'a'.charCodeAt()); // 97

// String.fromCharCode() - Получится символ в обратную сторону из числа
console.log(String.fromCharCode(97)) // 'a'
console.log(String.fromCharCode(65)) // 'A

// == vs ===
// == сравнивает значения
console.log("'1' == 1", '1' == 1);
console.log("'200' > '21'", '200' > '21');
console.log("true == 1", true == 1);

// === сравнивает типы (рекомендовано)
console.log("1 === 1", 1 === 1)
console.log("true === 1", true === 1)
---------------------------------------------------------
//// Math() 
console.log('Math объекты');
console.log('Число Pi', Math.PI); // 3.141592653589793

//// Округление

// Math.round() – простое округление
console.log('Простое округление:');
console.log('Math.round(40.4)', Math.round(40.4)); // 40
console.log('Math.round(40.5)', Math.round(40.5)); // 41
console.log('Math.round(40.6)', Math.round(40.6)); // 41

// Math.floor() – округление вниз
console.log('Округление вниз:');
console.log('Math.floor(40.5)', Math.floor(40.5)); // 40
console.log('Math.floor(40.9)', Math.floor(40.99)); // 40

// Math.ceil() – округление вверх
console.log('Округление вверх:');
console.log('Math.ceil(40.1)', Math.ceil(40.1)); // 41
-------------------
//// Math.random(). Создание рандомного числа с помощью 

   function getRandomInt (min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min)
   };
   console.log('getRandomInt', getRandomInt (3, 6));
---------------------------------------------------------
// .toFixed(x) - обрезает/сокращает значение
let result = Number((amount / rate).toFixed(2)); // .toFixed(2) - обрезает значение до 2х символов. 
---------------------------------------------------------
//// Условное ветвление

if (если да, то)
else (что-то другое)
if else (если другое "да", то)
switch case (случай) - замена else & if
? : - замена else if

//// {if} {else}

if (условие) {
  // Выполнится, если условие будет истинным
} else {
  // Выполнится, если условие будет ложным
}

let isFrontendDeveloper = true;

if (isFrontendDeveloper) {
   console.log('isFrontendDeveloper = true','You are a Front-End developer. Welcome to the team!');
} else {
   console.log('isFrontendDeveloper = false', 'You are not a Front-End developer');
}

const condition = 5 > 10; // вернет false
if (condition) {
  console.log('Выражение истинно!');
} else {
  console.log('Выражение ложно!');
}
Вывод: Выражение ложно!

let developerJobType = 'Front-End';

if (developerJobType === 'Front-End') {
   console.log('2000$');
} else if (developerJobType === 'Back-End') {
   console.log('1500$');
} else if (developerJobType === 'Full-Stack') {
   console.log('3500$');
} else {
   console.log('Зарплата не определена');
---------------------------------------------------------
//// switch case / break / default 

   let a = 2 + 2;

   switch (a) {
      case 3:
         alert( 'Маловато' );
         break;
      case 4:
         alert( 'В точку!' );
         break;
      case 5:
         alert( 'Перебор' );
         break;
      default:
         alert( "Нет таких значений" );
      }
-------------------
   let developerJobType = 'Front-End';

   switch (developerJobType) {
      case 'Front-End':
         console.log('2000$');
         break;
      case 'Back-End':
         console.log('1500$');
         break;
      case 'Full-Stack':
         console.log('3500$');
         break;
      default:
         console.log('Зарплата не определена');
---------------------------------------------------------
//// ? : - замена else if

let favoriteDrink = '???'

let message = favoriteDrink === 'Coffee' // условие 
   ? 'Your favorite drink is coffee' 
   // после '?' выполняет если условие 'true'
   : 'You most likely have a healthy CNS'; 
   // после ':' выполняет если условие 'false'

let question2 = prompt ('Сколько будет 2 * 2?') 
    question2 = Number(question2)

   question2 === 2 * 2
   ? alert('Ответ Верный') + correctAnswers++
   : alert('Ответ Неверный') + incorrectAnswers++;
-------------------
// Несколько операторов „?“

   let age = prompt('Возраст?', 18);

   let message = (age < 3) ? 'Здравствуй, малыш!' :
   (age < 18) ? 'Привет!' :
   (age < 100) ? 'Здравствуйте!' :
   'Какой необычный возраст!';

   console.log('message:', message);
---------------------------------------------------------
// && (И) - И возвращает true, если оба аргумента истинны, а иначе – false:
   alert( true && true );   // true
   alert( false && true );  // false
   alert( true && false );  // false
   alert( false && false ); // false
// || (ИЛИ) - Если какой-либо из аргументов true, он вернёт true, в противоположной ситуации возвращается false.
   alert( true || true );   // true
   alert( false || true );  // true
   alert( true || false );  // true
   alert( false || false ); // false
// ! (НЕ)
// ?? (Оператор объединения с null) - Пропускает только значения "null" и "undefined" 

//// && (И) - Ищет и выводит значение с "false". Значения  "true" пропускаются.
Пропускает алгоритм далее если оба значения true:
if (existingUserLogin === userLogin && existingUserPassword === userPassword) {
  alert(`Добро пожаловать, ${userLogin}!`);
} else {
  alert("Логин и (или) Пароль введены неверно!");
}

console.log('//&& (И)//');

let userAge = 20;

if (userAge > 6 && userAge <= 18) {
   console.log('Пользователь ходит в школу');
} else {
   console.log('Пользователь НЕ ходит в школу');
}


let programingLanguage = 'JavaScript'
let experienceInYear = 1;

if (programingLanguage === 'JavaScript' && experienceInYear >= 1) {
   console.log('Добро пожаловать в нашу команду');
} else {
   console.log('Нужно бооольше опыта');
}

//// || (ИЛИ) - Ищет и выводит значение с "true". Значения  "false" пропускаются.

let currentHour = 10;

if (currentHour < 8 || currentHour > 20) {
   console.log('Наш офис Закрыт');
} else {
   console.log('Наш офис Открыт');
}


let userNickname = null;
let defaultNicname = 'User';

let nickname = userNickname || defaultNicname || 'noname';
console.log('nickname', nickname);

//// ! (НЕ)
let = answer = prompt ('How old are you?')
answer = Number(answer);

if (!answer) {
   alert('Enter your total number of years')
} else {
   alert(`You are ${answer} years old`)
}

Предположим, у нас есть сайт и мы хотим сделать какие-то действия, если пользователь не авторизован. Также у нас есть переменная isAuth:
let isAuth = false; //if (existingUserPassword === userPassword) {
   alert (`Добро пожаловать, ${userPassword}`)
} Пользователь не авторизован

if (!isAuth) {
  // Пользователь не авторизован, условие выполнится
}
Условие сработает, так как !isAuth === true и в if будет передано true. 

//// ?? (Оператор объединения с null)

// ?? - undefined, null 
console.log(false ?? 'Hello worldblat!');

// || - false, 0, "", NaN, indefined, null
console.log(false || 'Hello worldblat!');

---------------------------------------------------------
//// Циклы 
---------------------------------------------------------
// Переменные в циклах не видны за их пределами. 
// Чтобы переменные были видны ни только в цикле о и за ним, необходимо создать эту переменную заранее.

//// for () {}

// for (начальное значение; условие (до тех пор пока); шаг) {
   ... тело цикла ...
};

   for(let i = 0; i<5; i++){
      
      console.log(i);
   }
   console.log("Конец работы"); 
   // 0
   // 1
   // 2
   // 3
   // 4
   // Конец работы
---------------------------------------------------------
//// Перебор Массивов
---------------------------------------------------------
/// for
-------------------
   for (let i = 0; i < developerNames.length; i++) {
      console.log('i', i);
      console.log('item', developerNames[i]);
   }
-------------------
// Посчитать сумму значений массива (for)
-------------------
   let sum = 0;
   for (let i = 0; i < arr.length; i++) {
      sum += arr[i];
   }
-------------------
/// for of
-------------------
   for (const item of object) {
      // item - переменная отвечающая за элемент массива
      // object - название перебираемого массива/объекта
   };
-------------------
   for (const name of developerNames) {
      console.log('name', name);
   };
-------------------
   let iterable = [10, 20, 30];

   for (let value of iterable) {
      value += 1;
      console.log(value);
   };
   // 11
   // 21
   // 31
-------------------
/// forEach (рекомендуется)
-------------------
forEach - не нуждается в [i] при переборе, он сам сдвигает очередь элементов без упоминания счетчика циклов (i)

   let updatedStudent = [
      ...students,
   ];

   updatedStudent.forEach((el, i) => {
      el.job = "веб-разработчик";
   });

-------------------
   array.forEach(() => {}); 
   forEach это метод массива => необходимо обращаться к массиву.

   array.forEach((элемент, индекс, массив) => {
   // тело функции
   })

1. Метод forEach() принимает в себя функцию-callback. Callback - это функция, которая передается в другую функцию.
2. В свою очередь, функция принимает в себя три параметра:
   - Элемент. Данный параметр принимает в себя, непосредственно, значение каждого элемента массива по порядку.
   - Индекс. Данный параметр является опциональным (необязательным) и принимает в себя индекс текущего элемента массива.
   - Массив. Данный параметр также является опциональным и каждый раз принимает в себя текущий массив.
3. Тело функции. В данном месте мы прописываем всю необходимую логику. Она будет выполняться для каждого элемента массива.   

   developerNames = [
      'Maxim',
      'Jora',
      'Kiristina',
      'Alberto',
      'Djovanni'
   ];

   developerNames.forEach((name, index, array) => {
      console.log('name', name);
      console.log('index', index);
      console.log('array', array);
   });
---------------------------------------------------------
// Проверка четных / нечетных чисел с помощью оператора получения остатка от деления %.
   for (let i = 0; i <= 10; i++) {
      if (i % 2 == 0) {
         console.log(i);
      }
   }   
--------------------------------------------------------- 
// Найти делители числа и их количество

   let n = 12, divisor = [];
      for (let i = 1; i <= n; i++) {
         if (n % i == 0) {
            divisor.push(i);
         }
      }
console.log(`Делители числа ${n}:  ${divisor}`);
console.log(`Кол-во делителей числа:  ${divisor.length}`);
-------------------
function getDivisors (number) {
   let counter = 0;
      for (let i = number; i > 0; i--) {
         if (number % i === 0) {
            counter++;
         }
      };
      return counter;
}; // Найти кол-во делителей
---------------------------------------------------------
// Сохранить результат каждой итерации цикла for

Создать массив, и пушить результат при каждой итерации в него:
   var array = [];
   for (i = 1; i <= 3; i++) {
      var x = 0;
      x += (i); 
      array.push(x);
   }
// Or
   var array = [];
   for (i = 1; i <= 3; i++) {
      array.push(i);
   }
// Or
   var x = 0;
   for (i = 1; i <= 3; i++) {
      x += i;
   }
   var array = [],
// Or
   x = 0;
   for (i=0; i<=3; i++){
   x += (i); 
   array.push(x);
   }
   console.log(x);
-------------------
   for (let x = 0; x <= 10; x += 1) {
      console.log('x = ', x);
   };

   for (let value = 10; value >= 0; value -= 1) {
      console.log('value = ', value);
   };
-------------------
   for (let i = 0; i < 3; i += 1) {
      let newStudent = prompt("Введите имя нового студента!"); 
      if (newStudent) {
      newStudent = newStudent.trim();
      alert(`Добро пожаловать, ${newStudent}!`);
      }
   } // Будет повторять вывод тела функции (Вопрос об имени, Приветствие + Имя)  3 итерации, до тех пор пока (i < 3)

   let sequence = [1, 1, 2, 3, 5, 8, 13];
   for (let i = 0; i < sequence.length; i++) {
   console.log(sequence[i]);
   } 
   // 1, 1, 2, 3, 5, 8, 13
   // Цикл выводит следующее значение в консоль по порядку, тк указано sequence[i]. sequence с индексом [i] на начальном этапе подразумевает что i = 0 (тк отсчет указан с 0), а даной цифре отсчета соответствует индекс массива [0], в данном случае индекс массива sequence[0] = 1. А тк i++, цикл движется дальше на +1 ход вперед к следующему индексу массива.

// function calculateFlights (distance, isBusinessClass, milesTarget) {
      // body //
   };
   
   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   let flightsVariant1 = calculateFlights(3118, true, targets[i]);
   let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   for (let i = 0; i < targets.length; i++) {
      flightsVariant1();
      flightsVariant2(); 

   // Так не сработает! "ReferenceError: i is not defined". 
   // flightsVariant1/2 - как не знал до этого так и не знает что за значение "i"."i" становится известно лишь после обьявления цикла.

   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   for (let i = 0; i < targets.length; i++) {
      let flightsVariant1 = calculateFlights(3118, true, targets[i]);
      let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   // Так сработает!
---------------------------------------------------------
//// Замена for (без возможности использовать инедекс i)

const userNames = ['petya', 'vasya', 'evgeny'];

// name на каждой итерации свой собственный (локальный), поэтому используется const
for (const name of userNames) {
  console.log(name);
}
   // => "petya"
   // => "vasya"
   // => "evgeny"

---------------------------------------------------------
//// while - сначала смотрит условие, потом делает
console.log('//while//');

// while (условие) {}

   let i = 0;
   while (i < 10) {
      console.log('i = ', i);
      i += 1;
   }

---------------------------------------------------------
//// do while - сначала делает, потом смотрит условие

   let i = 0;
   do {
      i += 1
      console.log('i = ', i);
   } while (i <= 5) // Выдаст 6, начав с 1 (тк сначала делает, а потом проверяет. Важна последовательность)

   let i2 = 0;
   do {
      console.log('i2 = ', i2);
      i2 += 1
   } while (i2 <= 5) // Выдаст 5, начав с 0 

---------------------------------------------------------
//// break 

   let z = 0;
   while (z < 10) {
   console.log(z);
   if (z === 3) break;
   z++;
   }
Остановится на 3х. Выведет: 0 1 2 3

---------------------------------------------------------
//// continue 

   for (let f = 0; f <= 5; f++) {
      if (f === 2) continue;
      console.log(f);
   }
Пропустит 2. Выведет: 0 1 3 4

---------------------------------------------------------
//// Массивы
---------------------------------------------------------
let target = [
   {nameTown:'Saskatoon', km: 3000}, 
   {nameTown:'Asuncion', km: 7000}, 
   {nameTown:'Tokio', km: 15000}
   ];

   for (let i = 0; i < target.length; i++) {
      const el = target[i];
      console.log(`Town name: ${el.nameTown} km: ${el.km}`);
   }
//Or
   target.forEach(el => console.log(el.nameTown)); // Saskatoon Asuncion Tokio
   target.forEach(el => console.log(el.km)); // 3000 7000 15000
-------------------
// Обычный вызов
   const el = target[0];
   console.log(`Town name: ${el.nameTown} km: ${el.km}`)
-------------------
let fruits = ["Яблоко", "Апельсин", "Слива"];
   alert( fruits[0] ); // Яблоко
   alert( fruits[1] ); // Апельсин
   alert( fruits[2] ); // Слива
-------------------
let numbers = [0, 0, 0, 0, 1];
let sum = 0;

for (let i = 0; i < numbers.length; i += 1) {

   numbers[i] = numbers[i] + 2; 
   // При каждом проходе цикла прибавляет к "i" +1, что пошагово продвигает цикл по элементам [ ] массива "numbers".
   Будет получаться:
   numbers = [2, 0, 0, 0, 1]; - 1й проход цикла
   numbers = [2, 2, 0, 0, 1]; - 2й проход цикла
   numbers = [2, 2, 2, 0, 1]; - 3й проход цикла
   numbers = [2, 2, 2, 2, 1]; - 4й проход цикла
   numbers = [2, 2, 2, 2, 3]; - 5й проход цикла

   sum = sum + numbers[i];
   // Складывает к переменной "sum" актуальное значение массива (в зависимости на какой позиции сейчас находится цикл)
   sum = 0 + 2 = 2
   sum = 2 + 2 = 4
   sum = 4 + 2 = 6
   sum = 6 + 2 = 8
   sum = 8 + 2 = 11
}
console.log(sum); // 11
-------------------
// Выявить min / max значение из массива:

   let arr = [22,4,7];
   console.log(Math.min(...arr));
-------------------
// Разные типы значений
   let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

   получить элемент с индексом 1 (объект) и затем показать его свойство
   alert( arr[1].name ); // Джон

   получить элемент с индексом 3 (функция) и выполнить её
   arr[3](); // привет

// let cities = [
   {Valencia: 3118}, 
   {Lisbon: 3617}, 
   {Saskatoon: 3000}, 
   {Asuncion: 7000}
   ];

(cities[0].Valencia); // 3118
(cities[0]); // { Valencia: 3118 }
---------------------------------------------------------
//// Массивы (edit/delete/add)
---------------------------------------------------------
// Мутация массива 
JavaScript предоставляет несколько способов для добавления, удаления и замены элементов в массиве. Но некоторые из них используют мутацию, то есть видоизменяют изначальный массив, а некоторые — нет, они просто создают новый массив.
-------------------
I. Добавление: С мутацией
-------------------
Мутирующими методами для добавления элементов в массив:
  * array.push()
  * array.ushift()

-------------------
III. Удаление: С мутацией
-------------------
Методы для удаления элементов с мутацией: 
  * array.pop()
  * array.shift()
  * array.splice()
-------------------
II. Добавление: Без мутации
-------------------
Есть два способа, чтобы добавить новые элементы в массив без мутации изначального массива:
  * array.concat().
  * (...)
-------------------
   1) array.concat().
const arr1 = ['a', 'b', 'c', 'd', 'e'];

const arr2 = arr1.concat('f'); // ['a', 'b', 'c', 'd', 'e', 'f']
console.log(arr1); // ['a', 'b', 'c', 'd', 'e']
-------------------
   2) (...)
   Второй способ для добавления элементов без мутации — это использование оператора расширения. Оператор расширения записывается в виде трех точек (...) предшествующих массиву.

const arr2 = [...arr1, 'f']; // ['a', 'b', 'c', 'd', 'e', 'f']
const arr3 = ['z', ...arr1]; // ['z', 'a', 'b', 'c', 'd', 'e']
-------------------
IV. Удаление: Без мутации
-------------------
  * array.filter()
  * array.slice()
Метод array.filter() создает новый массив из первоначального массива, но новый содержит только те элементы, которые соответствуют заданному критерию.

   const arr1 = ['a', 'b', 'c', 'd', 'e'];
   const arr2 = arr1.filter(a => a !== 'e'); // ['a', 'b', 'd', 'f']  
// Or
   const arr2 = arr1.filter(a => {  
   return a !== 'e';
   }); // ['a', 'b', 'd', 'f']

В этом примере, критерием для отсеивания является неравенство 'e', поэтому новый массив (arr2) почти такой же, как и оригинальный, но содержащий только те элементы, которые не равны 'e'.

Некоторые особенности стрелочных функций:
Для однострочных стрелочных функций ключевое слово return подразумевается по умолчанию, так что вам не нужно писать его.
Однако для многострочных стрелочных функций нужно явно указывать возвращаемое значение.
Другой способ удалить элементы из массива без мутации — это использование array.slice(). (Не путать с array.splice())

array.slice() принимает два аргумента.
   Первый аргумент указывает откуда должна начинаться копия.
   Второй аргумент задает последний индекс не включительно.

const arr1 = ['a', 'b', 'c', 'd', 'e'];

const arr2 = arr1.slice(1, 5) // ['b', 'c', 'd', 'e']
const arr3 = arr1.slice(2) // ['c', 'd', 'e']

На строке с кодом const arr2 = arr1.slice(1, 5), arr2 создается путем копирования arr1 начиная с индекса 1 и заканчивая предыдущим индексом для 5 (то есть 4).

На следующей строке const arr3 = arr1.slice(2) показан полезный трюк. Если второй параметр метода array.slice() не задан, то метод берет копию с начального индекса до конца массива.
---------------------------------------------------------
// Добавление элементов
---------------------------------------------------------
   const salariesOfDev = [400, 500, 600, 2000, 3500];
   const newSeniorDevSalary = 5000;

// .push() - добавляет в конец 
   salariesOfDev.push(newSeniorDevSalary); 
   console.log('salariesOfDev', salariesOfDev);

// .unshift() - добавляет в начало 
   salariesOfDev.unshift(101, 202, 303) 
   console.log('salariesOfDev', salariesOfDev);
-------------------
// Удаление элементов
-------------------
// .shift() - удаляет первый элемент массива и возвращает его значение в переменную (если имеется)
   const firstRemovedElement = salariesOfDev.shift(); 
   console.log('firstRemovedElement', firstRemovedElement);

// .pop() - удаляет последний элемент массива и возвращает его значение в переменную (если имеется)
   const lastRemovedElement = salariesOfDev.pop(); 
   console.log('lastRemovedElement', lastRemovedElement);
-------------------
// Изменение элементов
   salariesOfDev[4] = 6000;
-------------------
// Получение элементов
-------------------
   array[3]
// Or
   array.at(3)

   array[array.length - 1] - чтобы получить последний элемент массива
-------------------
// arr.slice 
-------------------
   let arr = ["t", "e", "s", "t"];
   alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая END).
Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива
-------------------
// Получить последний элемент массива
-------------------
  * array[array.length - 1] // Выполняется дольше всех
  * array.slice(-1) // Возвращает typeof: String
  * array.pop() // Вырезает элемент из массива

--------------------------------------------------------
// array.forEach()

Метод используется для перебора массива.

   arr.forEach(function callback(item, index, array)){
      ... делать что-то с item
      }); 

Он для каждого элемента массива вызывает функцию callback.
Этой функции он передаёт три параметра callback(item, i, array):
    item – очередной элемент массива.
    i – его номер.
    array – массив, который перебирается.

Например, этот код выведет на экран каждый элемент массива:
   ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
 // Вызов alert для каждого элемента

А этот вдобавок расскажет и о своей позиции в массиве:
   ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
   alert(`${item} имеет позицию ${index} в ${array}`);
   });

///  arr = [
      {name:'Saskatoon', value: 3000}, 
      {name:'Asuncion', value: 7000}, 
      {name:'Tokio', value: 15000}
   ];

   arr.forEach(el => console.log(el.name));
   arr.forEach(el => console.log(el.value));
---------------------------------------------------------
//// Работа с методами массивов: map(), filter(), find(), findIndex(), some(), every()
---------------------------------------------------------

// map - модифицирует каждый элемент массива и возвращает данные в новый массив
   ! Не забывай писать return! или если функция в одну строчку, то после "=>" подразумевается return.
   ! Так же помни, что return в конце цикла тормозит итерации цикла на 1 круге! (необходимо выносить его за цикл)

   const  salariesOfDevelopers = [ 400, 500, 600, 2000, 350];

   const updatedSalaries = salariesOfDevelopers.map((salary,index, array) => {
      return salary ** 2
   });
   console.log('updatedSalaries', updatedSalaries);
-------------------
   let searchName = 'barry';
   let index = inputArr.map(el => el.name).indexOf(searchName);

-------------------
// filter - фильтрует каждый элемент массива и возвращает данные в новый массив. (добавляет в массив если условия == true)

   const filtredSalaries = salariesOfDevelopers.filter((salary,index, array) => {
      return salary > 600 // [ 2000 ]
      // return index % 2 == 0 // [ 400, 600, 350 ]
   });
   console.log('filtredSalaries', filtredSalaries);

-------------------
// find - находит первый найденный элемент, выводит в новый массив

   const searchedSalary = salariesOfDevelopers.find(salary => {
      return salary > 500
   });
   console.log('searchedSalary', searchedSalary);

-------------------
// findIndex - возвращает первый найденный индекс элемента, выводит в новый массив

   const searchedIndex = salariesOfDevelopers.findIndex(salary => {
      return salary > 500
   });
   console.log('searchedIndex', searchedIndex);

findIndex() Найти нужный элемент объекта в массиве. 

   let patients = [
   { id: 1, name: "Максим" },
   { id: 2, name: "Николай" },
   { id: 3, name: "Ангелина" },
   { id: 4, name: "Виталий" }
];

   const indexOfPatients = patients.findIndex((el, i) => {
      return el.id ==  3;
   })
   console.log('indexOfPatients', indexOfPatients);
-------------------
// some, every - 
some == true если хотя бы 1 элемент массива удовлетворяет условию
every == true если все элементы массива удовлетворяет условию

   const elementExists = salariesOfDevelopers.some(salary => {
      return salary > 1000
   });
   console.log('elementExists', elementExists);

   const allElementExists = salariesOfDevelopers.every(salary => {
      return salary > 1000
   });
   console.log('allElementExists', allElementExists);
-------------------
// .reduce() Сложение чисел массива, которые возвращаются в новую переменную

   const value = array.reduce((аккумулятор, элемент, индекс, массив) => {
   // тело функции
   }, начальное значение)

Метод reduce() принимает в себя два параметра:

   1. Функцию-callback, которая, в свою очередь, принимает в себя четыре параметра:
      * Аккумулятор. Он равен “начальному значению” при первом вызове функции, либо первому элементу массива, если “начальное значение” не задано. При последующих вызовах он равен результату предыдущего вызова функции.
      * Элемент - текущий элемент массива.
      * Индекс - индекс текущего элемента массива. Необязательный параметр.
      * Массив - текущий массив. Также является необязательным параметром.
   2. Начальное значение - значение, которое будет задано аккумулятору перед первым вызовом функции. Является необязательным параметром. Если он не задан, тогда аккумулятору присвоится значение первого элемента массива.
   3. Тело функции. В нем мы прописываем всю необходимую логику.
-------------------
// .reduce() при работе с аргументами функции, с использованием ...rest

   function sum(...other) {
   console.log(other.reduce((acc, value) => acc + value)); 
}
   sum(1, 2, 3);  // 6
   sum(2, 2); // 4
   sum(10, 15, 249, 653, 846); // 1773
-------
   const euros = [29.76, 41.85, 46.5, 55.8, 43.6];

   const sum = euros.reduce((total, amount) =>  total + amount); 
   console.log('sum', sum); // 217.51 (Debuger to help)

* В этом примере reduce() принимает два параметра, total и число с которым сейчас идёт работа.
* Метод проходится по каждому числу в массиве, как бы это было с циклом for.
* Когда цикл только начинается, total имеет значение первого числа с начала массива (29.76), а числом в обработке становится следующее по этому же массиву число (41.85).
* Конкретно в этом примере, нам надо прибавить настоящее число к total.
* Такое вычисление повторяется для каждого числа в массиве и каждый раз настоящее число меняется на следующее число в массиве справа.
* Когда уже нет чисел в массиве, метод отдаёт значение total.
-------------------
// sort() - Сортировка значений массива. Изменяет массив
Внимание! При передачи просто sort(), без callback, то будет преобразование элементов в 'string'

   salariesOfDevelopers = [ 400, 500, 600, 2000, 350];

   salariesOfDevelopers.sort((a, b) => {
      return a - b // Сортировка по возрастанию
      return b - a // Сортировка по убыванию
   });
   console.log('salariesOfDevelopers', salariesOfDevelopers);
-------
   let arr = [76, 25, 58, 91, 27]

   console.log('arr.sort', arr.sort());

Метод sort() работает по следующему принципу:

   * sort() должен вернуть значение меньше нуля, равное нулю или больше нуля.
   * Если вернется значение меньше нуля, сортировка поставит a по меньшему индексу, чем b, то есть, a будет идти первым.
   * Если вернется значение больше нуля, сортировка поставит b по меньшему индексу, чем a, то есть, b будет идти первым.
   * Если вернётся значение равное нулю, сортировка оставит a и b неизменными по отношению друг к другу.

   const array = ['b', 'd', 'c', 'a', 'e', 'f', 'g'];
   array.sort((a, b) => {
   if (a < b) {
      return 1;
   }
   if (a > b) {
      return -1;
   }
   return 0;
   });
   console.log(array); // ['g', 'f', 'e', 'd', 'c', 'b', 'a']
-------------------
// splice - возвращает вырезанные элементы. Мутирует текущий массив. Может принимать новые значения для замены вырезанных.

const cars = ['BMW', 'Mercedes', 'Lada'];

const removedElements = cars.splice(0, 2, 'Audi', 'Bugatti')

console.log('cars', cars); // 'Audi', 'Bugatti', 'Lada' 
console.log('removedElements', removedElements); // 'BMW', 'Mercedes'
-------------------
// slice - возвращает вырезанные элементы. Не мутирует текущий массив.

const agesOfDevelopers = [25, 18, 45, 30];

const slicedAgesOfDevelopers = agesOfDevelopers.slice(0, 2);
console.log('slicedAgesOfDevelopers', slicedAgesOfDevelopers);
console.log('agesOfDevelopers', agesOfDevelopers);
-------------------
// indexOf - возвращает индекс искомого элемента в переменную
(или используй для объектов "findIndex")
   
   const favoriteFood = ['Мясо', 'Торт', 'Кефирчик'];

   const indexOfFood = favoriteFood.indexOf('Мясо')
   console.log('Element:', favoriteFood[indexOfFood], 'Index:', indexOfFood);
-------------------
   const myText = 'Здесь должна была быть шутка, но я ее не придумал';

   console.log('indexOf', myText.indexOf('о')); // 7
   console.log('indexOf', myText.indexOf('шутка')); // 23
   console.log('indexOf', myText.indexOf('мыш кыш')); // -1

   console.log('includes', myText.includes('не придумал')); // true
-------------------
// includes - элемент есть/нет

const technologies = ['JS', 'HTML', 'CSS'];

const isTechnologiesExists = technologies.includes('CSS')
console.log('isTechnologiesExists', isTechnologiesExists);
-------------------
// split - разделяет массив. Принимает в себя разделитель.

   const listOfOrders = 'Майка, шорты, кроссовки, рюкзак';

   const listOfOrdersArray = listOfOrders.split(', ')
   console.log('listOfOrdersArray', listOfOrdersArray);
-------------------
// join - превратить массив обратно в строчку. Принимает в себя разделитель.

   const ordersString = listOfOrdersArray.join('; ')
   console.log('ordersString', ordersString);
-------------------
// reverse - полностью переворачивает массив

let numbers = [1, 10, 5, 15]
numbers.reverse();
console.log('technologies', numbers);
---------------------------------------------------------
/// Объединение массивов 
---------------------------------------------------------
let currentDevelopers = ['Maxim', 'Oleg'];
let newDevelopers = ['Anton', 'Gleb']
-------------------
// concat() 
-------------------
[1, 2, 3].concat([4, 5, 6]) // [1, 2, 3, 4, 5, 6]

let allDevelopers = currentDevelopers.concat(newDevelopers);
console.log('allDevelopers', allDevelopers);
-------------------
// Spreed-оператор "..." 
-------------------
allDevelopers = [
   ...newDevelopers,
   ...currentDevelopers
];
console.log('allDevelopers', allDevelopers);

-------------------
// Array.length - число элементов этого массива
-------------------
   let items = ['shoes', 'shirts', 'socks', 'sweaters'];
   console.log(items.length); // 4
---------------------------------------------------------
/// Найти индекс элемента в массиве объектов по элементу из другого массива
---------------------------------------------------------
   let orders = [4, 1, 2, 3]
   let patients = [
      { id: 1, name: "Максим" },
      { id: 2, name: "Николай" },
      { id: 3, name: "Ангелина" },
      { id: 4, name: "Виталий" }
   ];
-------------------
// for Метод

let patientsInOrder = [];

function giveTalonsInOrder (patients, orders) {
   for (let i = 0; i < orders.length; i++) {
      let queue = orders[i];
   
      for (let j = 0; j < patients.length; j++) {
         let patientId = patients[j]['id'];
   
         if (queue === patientId) {
            patientsInOrder.push(patients[j])
         }
      }
   }
   return patientsInOrder
}
let queueOfPatientsResult = giveTalonsInOrder(patients, orders);
console.log('giveTalonsInOrder', queueOfPatientsResult);

-------------------
// findIndex() Метод

function giveTalonsInOrder (patients, orders) {
   let rightQueue = [];

   for (let i = 0; i < patients.length; i++) {
      let searchElement = orders[i];
      let patientsIndex = patients.findIndex(el => el.id === searchElement)
      rightQueue.push(patients[patientsIndex]);
      }
      return rightQueue
}
queueResult = giveTalonsInOrder(patients, orders)
console.log('Patients in order:', queueResult);

-------------------
// map() Метод

function giveTalonsInOrder (patients, orders, ) {
   let patientsQueue = [], rightQueue = [];

   for (let i = 0; i < patients.length; i++) {
      let searchElement = orders[i];
      patientsQueue = patients.map(el => el.id).indexOf(searchElement); // INFO*
      rightQueue.push(patients[patientsQueue]);
   };
   return rightQueue
}
let queueResult = giveTalonsInOrder(patients, orders)
console.log('Patients in order:', queueResult);

// INFO* Ищем индексы элементов массива orders в другом массиве.
// Тк мы знаем что по очереди должен идти пациент № 4, затем № 1, № 2, № 3
// И знаем что индексы этих позиций очередности разбросаны в другом массиве на индексах [3, 0, 1, 2]
// Следовательно в такой последовательности и необходимо вызывать массив пациентов, для соблюдения правильной очереди 

---------------------------------------------------------
//// Объекты
---------------------------------------------------------
   const developer = {
      // key: value,
      'My name': 'Maxim',
      job: 'Front-End Dev',
      experience: 24,
      jobAllInfo: {
         type: 'Front-End',
         framework: 'ReactJS'
      }
   }

// Вывести значение объекта
console.log('name:', developer.'My name'); // ошибка 
console.log('jobAllInfo:', developer.jobAllInfo);
-------------------
// Вывести значение объекта (для некоторых случаев)
console.log('name:', developer['My name']);
-------------------
// Вывести значение Объекта из Массива
console.log(arr[i].key);
-------------------
// Передача переменных с ключом из объекта
const key = 'job'
console.log('job:', developer[key]);
-------
   let fruit = prompt('Корзина фруктов:', 'mango');
   let fruitBasket = {
      [fruit]: 6
   };
   console.log('fruitBasket', fruitBasket);
   const car = {
   name: "Toyota Corolla"
   };
-------
   const key = "color";
   car[key] = "red";

   console.log(car); // { name: 'Toyota Corolla', color: 'red' }
-------------------
// Цепочки обращения к объектам
console.log('type', developer.jobAllInfo.type);
console.log('type', developer['jobAllInfo']['type']);
---------------------------------------------------------
/// Объект - ссылочный тип данных
---------------------------------------------------------
// Примитивы (хранение данных) 
   У каждой переменной — своё отдельное значение

   let x = 10;
   let xCopy = x; // Копируется значение
   xCopy = 20;
   
   console.log(x); // 10 (значение оригинальной x не изменилось)
   console.log(xCopy); // 20
-------------------
// Не примитив - Объект (ссылочный тип)
   В переменных типах object хранится не сам объект, а ссылка на него.

   const object = { x: 10 };
   const objectCopy = object; // Копируется ссылка на объект
   objCopy.x = 20;

   console.log(object.x); // 20
   console.log(objCopy.x); // 20

То есть, по сути, в двух переменных хранится один и тот же объект, точнее ссылка на него.

   const entity = {};
   const entityCopy = entity;

   console.log(entity === entityCopy); // true (Тк entityCopy хранит ссылку на объект entity. А их ссылки будут равны)

   console.log({} === {}); // false (здесь разные ссылки)
   console.log([] === []); // false (здесь разные ссылки)

   console.log('hello' === 'hello'); // true (тк у примитивов нет ссылок)
---------------------------------------------------------
/// Передача примитива и объекта в функцию
---------------------------------------------------------
   const x = 10;
   const updateX = arg => arg = 20;
   updateX(x);

   console.log(x); // 10 (оригинал переменой не изменен)
-------------------
   const obj = { x: 10 };
   const updateObjX = arg => arg.x = 20;
   updateObjX(obj);

   console.log(obj.x); // 20 (обновилось исходное значение)
---------------------------------------------------------
/// Объекты add/delete/edit
---------------------------------------------------------
   const student = {
      id: 1,
      programmingLanguage: 'JavaScript',
      hasExperienceInReact: false,
   };

// Добавление значения в объект:
-------------------
   student.experience = 6;
   console.log('student', student);
-------
   const student = {
      fullName: "Максим",
      experienceInMonths: 12,
      stack: ["HTML", "CSS", "JavaScript", "React"]
   };

   {
    ...student,
    job: jobName
  }
-------------------
// Удаление
   delete student.hasExperienceInReact;
   console.log('student', student);
-------------------
// Изменение
   student.experience = 12;
   console.log('student', student);

   const car = {
   name: "Toyota Corolla"
   };
-------------------
// Создание свойств
   car.engine = 1.6;
   car["maxSpeed"] = 185;
-------------------
// Обновление свойства
   car.name = "My Car";
   
   console.log(car); 
   { name: 'My Car', engine: 1.6, maxSpeed: 185 }
---------------------------------------------------------
/// Итерация объектов 
---------------------------------------------------------
const goodInfo = {
   id: 1,
   price: 80,
   currency: '$',
   name: 'shoes',
}
-------------------
// for in - проходится по ключам и свойствам объекта (устарел)

for (const key in goodInfo) {
   console.log('key:', key);
   console.log('value:', goodInfo[key]);
};
-------------------
// Object.keys - Создает массив из ключей. Выводит значения в отдельный массив

const keys = Object.keys(goodInfo);
console.log('keys', keys);
-------------------
// Object.values - Создает массив из значений. Выводит значения в отдельный массив

const values = Object.values(goodInfo);
console.log('values', values);
-------------------
// Object.entries - Возвращает многомерный массив, элементами которого являются другие массивы из ключей и значений. Выводит все в отдельный массив

   const entries = Object.entries(goodInfo);
   console.log('entries', entries); 
   // Выведет 
   // entries [
      [ 'id', 1 ],
      [ 'price', 80 ],
      [ 'currency', '$' ],
      [ 'name', 'shoes' ]
      ];
-------------------
   const car = {
      name: "Toyota Corolla",
      year: 2017,
      isNew: false
   };

   Object
      .entries(car) // Вернет массив [ ["name", "Toyota Corolla"], ... ]
      .forEach(arr => console.log(`${arr[0]}: ${arr[1]}`));

   // Выведет:
   // name: Toyota Corolla
   // year: 2017
   // isNew: false

Метод Object.entries() возвращает многомерный массив, то есть массив, элементами которого являются другие массивы. В каждом из этих подмассивов arr в первом элементе arr[0] хранится название свойства, а во втором arr[1] — его значение.
-------------------
Однако есть более элегантный способ работы с массивами в параметрах. Рассмотрим тот же код, но с использованием деструктуризации:

Object
   .entries(car)
   .forEach(([key, value]) => console.log(`${key}: ${value}`));

Здесь мы "разобрали" массив на отдельные значения. Делается это с помощью квадратных скобок с указанием переменных, куда нужно поместить значения из массива. Таким образом, список аргументов стрелочной функции ([key, value]) означает, что первое значение из записи будет помещено в переменную key, а второе значение в переменную value.

---------------------------------------------------------
//// Деструктуризация - позволяет извлекать данные из массивов или объектов.
---------------------------------------------------------
function calcValues (a, b) {
   return [
      a + b,
      undefined,
      a * b,
      a / b,
   ];
};
   const result = calcValues(42, 10);

   const sum = result[0];
   const sub = result[1];
   console.log('result:', result);
   console.log('sum, sub:', sum, sub);
-------------------
// С помощью деструктуризации
   const result = calcValues(42, 10);
/ Запись короче: 
   [sum, sub] = calcValues(42, 10)

   const [sum, sub] = result;
   console.log('result:', result);
   console.log('sum, sub:', sum, sub);
-------------------
// Игнорирование значений
-------------------
   const [sum, , mult, ...other] = calcValues(42, 10);
   console.log(sum, mult, other);
-------------------
// Значения по умолчанию
-------------------
   const [sum, sub = 'Вычитания нет', mult, ...other] = calcValues(42, 10);
   console.log(sum, mult, other, sub);
-------------------
   var a, b, rest;
   [a, b] = [1, 2];
   console.log(a); // 1
   console.log(b); // 2

   [a, b, ...rest] = [1, 2, 3, 4, 5];
   console.log(a); // 1
   console.log(b); // 2
   console.log(rest); // [3, 4, 5]

   ({a, b} = {a:1, b:2});
   console.log(a); // 1
   console.log(b); // 2

   ({a, b, ...rest} = {a:1, b:2, c:3, d:4});
   console.log(a); // 1
   console.log(b); // 2
   console.log(rest); // { c:3, d:4 }
-------
   var foo = ["one", "two", "three"];

   // без деструктурирования
   var one   = foo[0];
   var two   = foo[1];
   var three = foo[2];

   // с деструктурированием
   var [one, two, three] = foo;

-------------------
// Обмен значений переменных
-------------------
   var a = 1;
   var b = 3;

   [a, b] = [b, a];
-------------------
// Игнорирование некоторых значений
-------------------
   function f() {
   return [1, 2, 3];
   }

   var [a, , b] = f();
   console.log("A is " + a + " B is " + b);
   
После выполнения кода, a будет 1, b будет 3. Значение 2 игнорируется. Таким же образом вы можете игнорировать любые (или все) значения.
-------------------
// Деструктуризация с Объектами
-------------------
   const person = {
      name: 'Max',
      age: 20,
      address: {
         country: 'Russia',
         city: 'Moscow',
      },
   };

   const name = person.name;
   const age = person.age;
// Or
   const {
      name: firstName = 'Без имени', 
      age, 
      car = 'Машины нет',
      address: {country, city: homeTown}
   } = person;
   console.log(firstName, age, car, country, homeTown);
// key: variable - Смена значения переменной (если например занята)
   const {name, ...info} = person
   console.log(name, info);
-------------------
// Применение на практике 
-------------------
   function logPerson0 (per) {
      console.log(per.name, per.age);
   }
   logPerson0(person)
-------
   function logPerson1 ({name: firstName1, age}) {
      console.log(firstName1, age);
   }
   logPerson1(person)
---------------------------------------------------------
//// Symbol() - Создает уникальные ключи объекта. Позволяет использовать повторяющиеся ключи в объекте.
---------------------------------------------------------
// Пример ошибки однотипных ключей 
-------------------
let user = {
   name: 'Maxim',
   name: 'Igor',
   name: 'Michael',
}; // Сохраниться только последнее значение

console.log('user:', user); // { name: 'Michael' };

-------------------
// Решение с помощью Symbol() 
-------------------
const id = Symbol('name')

user = { 
   [id]: 'symbol value',
   name: 'Maxim',
   [Symbol('name')]: 'Igor',
   [Symbol('name')]: 'Michael',
};
console.log('user:', user);
console.log('user[id]:', user[id]);

-------------------
// in - Проверяет существует ли искомый ключ внутри объекта
-------------------
const searchInObject = 'name' in user
console.log('searchInObject', searchInObject); // true

console.log(id in user); // true
-------------------
В качестве имени ключа можно использовать переменные.
В объекте они означаются в "[]" 
   const key = "color";

   const car = {
   name: "Nissan Note",
   [key]: "silver"
   };

-------------------
// Создание скрытых свойств объекта с помощью Symbol()
-------------------
Использование символьных ключей гарантирует, что получить доступ к свойству мы можем, только имея ссылку на данный символ. Это может быть полезно, когда объекту нужно добавить свойство, которое другие части программы могут случайно изменить. При использовании symbol в ключе случайно зацепить свойство не получится. Также такие свойства не видны при переборе обычными способами (такими как цикл for...in или метод Object.entries()).

Для получения всех символьных ключей объекта можно использовать специальный метод Object.getOwnPropertySymbols().

   const car = {
   [Symbol("name")]: "Toyota Corolla",
   [Symbol("name")]: "Nissan Note"
   };

   const symbols = Object.getOwnPropertySymbols(car);
   for (const symbol of symbols) {
   console.log(`${symbol.description} - ${car[symbol]}`);
   }
   // Цикл выведет:
   // name - Toyota Corolla
   // name - Nissan Note

---------------------------------------------------------
//// Объединение нескольких Объектов в один
---------------------------------------------------------
   const developerInfo = {
      age: 25,
      experience: 3,
      name: 'Maxim'
   };

   const developerExtraInfo = {
      name: 'Igor',
      height: 180,
      isJunior: false,
   };

При слиянии, методы пропустят совпадающие ключи name и выведут только последний.
-------------------
// С помощью spreed оператора "..." (рекомендуется)
-------------------
   const developer = {
      ...developerInfo,
      ...developerExtraInfo,
      name: 'Nastya',
   };

   console.log('developer', developer); 
-------
Чтобы объединить объекты в массиве:
-------
При объединении объект-ы должны быть в "{}"

   const developer = [
      {...developerInfo},
      {...developerExtraInfo},
      {name: 'Nastya',}
   ];
-------------------
// С помощью Object.assign()
-------------------
   Object.assign(Объект-хранилище, перемещаемый объект)

   const developer2 = Object.assign(developerInfo, developerExtraInfo);

   console.log('developer2', developer2);
---------------------------------------------------------
//// ?. Оператор опциональной последовательности 
---------------------------------------------------------
// ("?." вместо "&&" в if)

const developer = {
   name: 'Maxim',
   job: 'Front-End Dev',
   experience: 24,
   jobAllInfo: {
      type: 'Front-End',
      framework: {
         nameFw: 'ReactJS'
      },
   }
}
-------------------
// if (developer.jobAllInfo.framework.nameFw)
-------------------
   if (developer && developer.jobAllInfo && developer.jobAllInfo.framework && developer.jobAllInfo.framework.nameFw) {
      console.log('The developer already knows the framework');
   } else {
      console.log("The developer doesn't knows the framework");
   }
-------------------
// ?. Оператор опциональной последовательности 
-------------------
   if (developer?.jobAllInfo?.framework?.nameFw) {
      console.log('The developer already knows the framework');
   } else {
      console.log("The developer doesn't knows the framework");
   }
---------------------------------------------------------
//// Функции 
---------------------------------------------------------
     С помощью них предотвращают дублирование кода. 
     Функция вызывается добавлением () после нее

// Анонимная функция вызывается:
   (function (){
   console.log("work");
   })();
// Or
   (function (str){
   console.log(str);
   }("work"));
-------------------
В функцию мы можем передавать параметры (любые типы данных). Одним из параметров может быть другая функция (например callback, alert, console.log) 

// Function Declaration - объявление функции
   (Можем вызывать функцию до ее определения)
   
   function name(param) {}

   function sum0 (a = 1, b = 3) {
      console.log(a + b);
   }
   sum0(); // 4
// Or
   function sum1 (a, b) {
      console.log(a + b);
   }
   sum1(1, 3); // 4
// Or
   function sum2 (a, b = 3) {
      console.log(a + b);
   }
   sum2(1); // 4
---------------------------------------------------------
//// Callback — это функция, в основной функции, которая должна быть выполнена после того, как другая (вторая) функция завершила выполнение (отсюда и название: callback — функция обратного вызова).

   function f2(callback) {
   let i = 0;
   i+=1;
   callback(i);
   }

   function handler(val) {
   console.log(val+1);
   }

   f2(handler);
-------------------
   function sum03(a, b, callback) {
   const result = a + b;
   callback(result);
   }

   function displayer(res) {
      console.log('Результат:', res);
   }

   sum03(3, 10, displayer);

/* Что тут происходит?
Создаем функцию sum03 с параметрами 'a', 'b', 'callback' 
(параметрами могут быть любые данные, даже функции, как и callback в данном случае.)
'callback' - это лишь произвольное название функции (хотя тут больше похоже на переменную со значением, чем на функцию. Но так как callback принимает значение от функции - это функция), в которую мы далее будем передавать полноценную функцию со значениями displayer. 

Создаем переменную result которая выполняет сложение двух неизвестных переменных 'a' и 'b' (пока их значение undefined)

Назначаем что функция callback будет иметь и выводить параметр result который хранит результат сложения.

Далее создаем функцию с наименованием displayer.
(которая в дальнейшем будет назначена передавать свое значение в callback. По сути можно сказать что callback = displayer)

Функция displayer имеет параметр res.
Далее тело функции displayer будет выводить в консоле строку 'Результат:' и переменную res (которую перенимает значения из result)

Далее самое важное. Мы передаем (назначаем) наши параметры функции sum 
Теперь (a, b, callback) = (3, 10, displayer)
a = 3
b = 10
callback = функция displayer

Грубо говоря, общая картина такова, что сумма значений 
(a + b) = result
result = callback 
callback = displayer
А так как displayer передает значения в callback, а callback хранит в себе значение переменной result, то есть сумму (a + b), то для функции displayer нам необходимо сохранить это значение в переменную res.

3 + 10 = 13. Помещается в функцию (параметр) callback и храниться в переменной result в качестве параметра.
А наш параметр callback является функцией displayer которая так же хранит в себе аналогичную переменню res в качестве параметра.

Получается displayer это отражение callback, которая хранит в себе все ее значения с небольшими дополненеиями. Которая могла бы вызываться по необходимости (в конце), то есть отдельно от выполнения главноего тела функции sum, где участвует callback.
*/

// Или это же, но через анонимную функцию (без названия)

   function sum04(a, b, anon_function) {
      const result = a + b;
      anon_function(result);
   }

   sum04(5, 10, function(res01) {
      console.log('Результат:', res01);
   });

// callback с уже существующими функциями 

   function sum05(a, b, alert) {
      const result = a + b;
      alert('Результат: ' + result);
   }

   sum05(5, 11, alert)
   
---------------------------------------------------------
//// Return - позволяет вернуть результат(значение) из функции 
*return - останавливает выполнение функции

// let increaseByTwo = function (number) {
      let sum = 2 + number;
      return sum;
   };

   increaseByTwo(1); // Функция вернёт 3
   increaseByTwo(2); // Функция вернёт 4

Чтобы функция вернула значение, мы используем оператор return. После оператора указываем, что именно надо вернуть. В нашем случае значение переменной sum. Когда программа доходит до строки с return, функция отдаёт результат своей работы и выполнение кода из тела функции останавливается, иными словами происходит выход из функции.

Несколько вещей, которые нужно знать:

   -Код, написанный на новой строке после return, не выполняется.
   -Функция не может вернуть сразу много значений, она возвращает только один результат.
   -Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, ничего.

---------------------------------------------------------
Обрати внимание на разницу между параметрами и аргументами. На практике зачастую эти слова взаимозаменяемы, но стоит понимать отличия:

    Параметр — это название переменной, которое указывается в объявлении функции. Они используются для многоразовости функции, для подставления в нее разных аргументов на место ярлыков(параметров). (price, count)
    Аргумент — это значение параметра, которое передается при вызове функции. (100, 5)

   function showTotalPrice(price, count) {
   console.log(price * count);
   };
   Данная функция имеет два параметра — цена (price) и количество (count). По сути это переменные, которым присваиваются значения при вызове функции.

   showTotalPrice(100, 5); // Выведет в консоль: 500
   showTotalPrice(350, 2); // Выведет в консоль: 700
   // Аргументы (100, 5)

---------------------------------------------------------
// document.querySelector('.селектор') - найти элемент
   console.log(document.querySelector('.селектор')) - удостовериться, что найден нужный элемент

// .classList.remove - удалить класс
   document.querySelector('.page').classList.remove('light-theme') - удалить класс в найденном селекторе

// .classList.add('dark-theme') - добавить класс
   document.querySelector('.page').classList.add('dark-theme');  - добавить класс в найденном селекторе 

Но это некорректная запись. Для нормализации читабельности, скорости и удобства кода назначим переменной значение поиска, чтобы не искать ее каждый раз.

   let page = document.querySelector('.page');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
   
///

   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
   };

'onclick' свойство (по клику) - это событие для браузера 

Данная конструкция создает переменную которая будет хранить в себе найденный класс с кнопкой для смены темы сайта.
При нажатии на кнопку будет запущенна функция удаления светлой темы и добавления темной.

// .classList.toggle - чередование переключения классов.
Удаляет(remove) если есть, добавляет(add) если нет.

   селектор.classList.toggle('класс');
   page.classList.toggle('light-theme');

Итого код для переключения темы:
   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.toggle('light-theme');
   page.classList.toggle('dark-theme');
   };

---------------------------------------------------------
// .textContent - выводит именно текст класса или селектора, а не код вместе с текстом

   let message = document.querySelector('.subscription-message');
   console.log(message.textContent);

С помощью .textContent можно переназначить текст
message.textContent = 'Измененный текст'
---------------------------------------------------------
'onsubmit' свойство - триггер на событие отправки формы (не кнопки!)

   let message = document.querySelector('.subscription-message');
   let form = document.querySelector('.subscription');

   form.onsubmit = function(evt) {
   // Инструкция ниже отменяет отправку данных
   evt.preventDefault();
   message.textContent = 'Форма отправлена!';
   };

---------------------------------------------------------
Отличия Function Declaration и Function Expression в том 
что FD мы можем вызывать до определения функции, а FE нет
---------------------------------------------------------
//// Рефакторинг 

Разработчики рефакторят свой код для того, чтобы он был понятен коллегам и самому автору через какое-то время, легко поддерживался, не содержал в себе повторов, огромных сложных конструкций и так далее. Здесь, как в школе: сначала пишем в черновик, пробуем, зачёркиваем, пробуем снова, пока не придём к решению, а потом аккуратно выводим в чистовик.

При этом рефакторингом занимаются все, даже самые крутые рок-звёзды из мира разработки.
---------------------------------------------------------
 Хороший код всегда состоит из множества частей, каждая из которых занимается только своей задачей.
---------------------------------------------------------
//// Arrow Function Expression
// Символ "=>" заменяет термин "function"

   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   };
   let result = sum(3.14, 3.14);
   console.log('Result:', result);

// Создаем имя функции "sum", вводим в () параметры, с помощью => обозначаем что это стрелочная функция которая переходит к телу {}. После "=>" без указания "{}", дальнейший текст будет воспринят как для команды "return".

   const sayHello = () => {
      alert("Hello");
   };

   const sayHello = (name) => {
      alert(`Hello, ${name}`);
   };  

const sayHello = name => alert(`Hello, ${name}`);
const calc = (a, b) => a + b;

sayHello("Vasya"); // Выведет сообщение "Hello, Vasya"
console.log(calc(1, 2)) // Выведет в консоль: 3

   let sum = function (a, b) {
      return a + b
   } 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   }

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => a + b; 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
   // Только если функция состоит из 1 строчки

---------------------------------------------------------
//// Использование Arrow Function как callback

   function multiply (a, b, callback) {
      const result = a * b;
      callback(result);
   }

   multiply(5, 2, (multiplyResult) => {
      console.log('multiplyResult:', multiplyResult);
   });

---------------------------------------------------------
//// Замыкания - функция внутри функции

// Замыкания — это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.
// Свободные переменные — это переменные, которые не объявлены локально и не передаются в качестве параметра.

   let numberGenerator = function() {
// Локальная переменная, которая доступна только в замыкании
      var num = 1;
      function checkNumber() {
         console.log(num);
      }
      num++;
      return checkNumber;
      }

   var number = numberGenerator();
   number(); // 2

В примере функция numberGenerator создаёт локальную «свободную» переменную num (число) и checkNumber (функция, которая выводит число в консоль). 
Функция checkNumber не содержит собственной локальной переменной, но благодаря замыканию она имеет доступ к переменным внутри внешней функции, numberGenerator. 
Поэтому объявленная в numberGenerator переменная num будет успешно выведена в консоль, даже после того, как numberGenerator вернёт результат выполнения.

Если посмотреть Debuger, то clg функции checkNumber будет выполняться последним. Почему? Тк идет передача этой функции в главную, с помощью return. А при вызове главной функции number(), следовательно и вызывается clg функции checkNumber.

-------------Разбор примера-------------
const createCounter = (initialValue = 0) => {
   return (valueToAdd) => {
      return initialValue + valueToAdd
   };
};

const addFive = createCounter(5);
const result = addFive(7);
console.log(result);

// Смотрим процесс через Debuger. До момента с назначением аргумента (5) функции createCounter все понятно. Далее это значение с параметром, упаковывается в переменную addFive. 
После, уже нынешняя переменная addFive(тобишь createCounter(5)) двигается далее и встречает return(1*), который возвращает в наш addFive вложенную анонимную функцию(со всеми ее значеними). 
То есть, теперь наш addFive != createCounter(5)
А имеет значение addFive = (valueToAdd) => {
      return initialValue + valueToAdd
   };
Это Debuger обработал первый(1*) return.
После процесс Debuger видит новый аргумент addFive(7)и переключается на него, одновременно упаковывая эти значения в переменную result.
И теперь самый важный момент. 
Параметр addFive стал (7). Но тут важно не ошибиться, addFive != исходному createCounter(5)
addFive имеет значение стрелочной функции с параметром (valueToAdd).
Поэтому при объявлении addFive(7), меняется параметр (valueToAdd). А дальше уже все понятно. Этот параметр используется в return для возврата initialValue + valueToAdd. 
Которые в итоге возвращаются в их анонимную стрелочную функцию которая = переменой addFive, которая уже ныне = переменой result, которая в последствии и выводится в консоль.

   createCounter = (initialValue = 0) => {
      let counter = initialValue;

      return (valueToAdd) => {
         counter += valueToAdd;
         return counter;
      };
   };

   const addTwo = createCounter(2);
   result = addTwo(10); // 12
   result = addTwo(5);
   result = addTwo(3);
   console.log(result);

---------------------------------------------------------
//// Область видимости переменных
---------------------------------------------------------
/// Глобальная область видимости
Позволяет переменной быть видимой из любой точки кода. Переменная считается глобальной, когда она объявлена вне функций и блоков:
const x = 10; // Глобальная переменная

   function show() {
   console.log(x); // Выведет 10
   }

/// Локальная область видимости (3 вида):
// Блочная -
Область видимости ограничена блоком кода (т.е. фигурными скобками { и }):

   if (true) {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined
   / Переменная x будет доступна только внутри блока if

   // Исключение — var. Они не имеют блочной области видимости и доступны даже вне блока.

// Область видимости функции -
Ограничена функцией, в которой объявлена переменная (Аналогично блочному)

   function test() {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined

// Модульная — область видимости ограничена модулем.

---------------------------------------------------------
/// Алгоритм поиска переменных
---------------------------------------------------------
   const x = 10;

   function show() {
   const y = 20;

   if (true) {
      const z = 30;
      console.log(x + y + z);
   }
   }
   show(); // Выведет в консоль 60   

В данном примере функция show() выводит в консоль сумму трёх переменных. При обращении к переменной x, движок JavaScript действует по такому алгоритму:

    Пытается найти переменную с именем x внутри блока if. Не найдя её, переходит к родительскому блоку наверх.
    Пытается найти переменную x в функции show(). Не найдя её, переходит к глобальному контексту.
    Находит глобальную переменную x и использует её значение.
    
   / Поиск происходит изнутри наружу. От локальных (точка отправления) к более глобальным

// При этом, если во внутреннем блоке уже найдена переменная с нужным именем, поиск останавливается:
   const x = 10;
   
   if (true) {
   const x = 20;
   console.log(x); // Выведет 20
   }
   console.log(x); // Выведет 10

---------------------------------------------------------
//// Выбор имени функции
---------------------------------------------------------
Функции, начинающиеся с…
    "get…" – возвращают значение,
    "calc…" – что-то вычисляют,
    "create…" – что-то создают,
    "check…" – что-то проверяют и возвращают логическое значение, и т.д.

showMessage(..)     // показывает сообщение
getAge(..)          // возвращает возраст (получая его каким-то образом)
calcSum(..)         // вычисляет сумму и возвращает результат
createForm(..)      // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвра
---------------------------------------------------------
// Number.isInteger(value) определяет, является ли переданное значение целым числом.
---------------------------------------------------------
   function fits(x, y) {
   if (Number.isInteger(y / x)) {
      return 'Fits!';
   }
   return 'Does NOT fit!';
   }

   console.log(fits(5, 10));
   // expected output: "Fits!"

   console.log(fits(5, 11));
   // expected output: "Does NOT fit!"
---------------------------------------------------------
//// Дата и Время
---------------------------------------------------------
// Создаем Объект
   const date = new Date(); 
   console.log('date', date);

   const newDate = new Date(2000, 0, 31, 00, 00, 0, 0); 
/ newDate(year, month, date, hours, minutes, seconds, ms) 
/ Месяца: 0 (январь) до 11 (декабрь)

   console.log('newDate', newDate); 
/ Mon Jan 31 2000 00:00:00 GMT+0000 (Coordinated Universal Time)

-------------------
// Создание даты из строки
-------------------
Также new Date() может принимать в себя строку с датой:

   const date = new Date('December 17, 2006 03:24:00');
   console.log(date); // Thu Dec 17 2006 03:24:00 GMT...

Это будет работать, если в конструктор был передан единственный аргумент с типом данных string.
-------------------
// Date.parse() 
-------------------
   Анализирует строку на наличие даты и переводит её в миллисекунды
   console.log(Date.parse('December 17, 2006 03:24:00')); 
-------------------
// Конвертировать миллисекунды в объект Date()
-------------------
   const dateInMs = 1498555006770
   const date = new Date(dateInMs)

   console.log(date.toString())
   / Tue Jun 27 2017 12:16:46 GMT+0300 (RTZ 2 (зима))
-------------------
// variable.get_() Вывести значение даты
-------------------
console.log('year', newDate.getFullYear());
console.log('month', newDate.getMonth());
console.log('date', newDate.getDate());
console.log('seconds', newDate.getSeconds());

-------------------
// variable.getDay() Вывести день недели
-------------------
/ 0 (Вс) - 6 (Сб)
   console.log('day', newDate.getDay());
   if (newDate.getDay() === 1) {
      console.log('Сегодня Пн') 
   }

-------------------
// variable.set_() Установить/передать дату
-------------------
   newDate.setFullYear(1996, 0, 31) // Можно установить ПолнуюДату
   console.log('newDate.FullYear', newDate);

-------------------
// Расчет разности между датами
-------------------
// getTime()

   const date1 = new Date(2005, 4, 20);
   const date2 = new Date(2006, 4, 10);

   console.log('date1', date1.getTime()); 
   console.log('date2', date2.getTime()); 
   / кол-во мс с Jan 1, 1970 

   const difference = date2.getTime() - date1.getTime();
   console.log('difference', difference / 1000 / 60 / 60 / 24); 
   / разница в днях (1000 * 3600 * 24)
-------------------
// Высчитывание скорости выполнения кода
-------------------
   const startTime = Date.now()
   for (let i = 0; i < 1000000; i++) {
      // do something
   }
   const endTime = Date.now()
   console.log('endTime - startTime:', endTime - startTime, 'ms');

-------------------
// timestamp - Date.now(). Количество мс с 1 января 1970 г.
-------------------
Чтобы добавить определенное число миллисекунд, можно использовать следующую запись:
    new Date(Date.now() + 5000)
В итоге мы получим дату, которая на 5000 миллисекунд больше текущей.
---------------------------------------------------------
//// Комбинаторное объединение с использованием Методов и Функций
---------------------------------------------------------
const getDateFormat0 = (date, separator = ".") => {

  const dateItem = date.getDate();
  const monthIndex = date.getMonth();
  const year = date.getFullYear();

  return [dateItem, monthIndex + 1, year]
    .map(addZero)
    .join(separator);
};

const addZero = (el) =>
  String(el).length === 1 ? `0${el}` : String(el);

console.log(getDateFormat(new Date()));
---------------------------------------------------------
//// Проверка класса: "instanceof"
---------------------------------------------------------
Оператор instanceof позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования.

  if (!(date instanceof Date)) {
    return "Первый параметр должен быть экземпляром класса Date!";
  }
---------------------------------------------------------
// this - ключевое слово указывающее на текущий контекст выполнения кода (чаще всего this - Объект)
---------------------------------------------------------
Простыми словами, this — это объект, который "владеет" функцией, которая сейчас выполняется.
-------------------
// Пример работы this и Функции в Объекте
-------------------
    let student = {
        name: 'Lamar',
        stack: [
            'HTML',
        ],
        level: 1,
        improveLevel() {
            this.level += 1
            if (this.level === 2) {
                this.stack.push('CSS')
            } else if (this.level === 3) {
                this.stack.push('JavaScript')
            } else if (this.level === 4) {
                this.stack.push('React')
            } else if (this.level === 5) {
                this.stack.push('NodeJS')
                console.log('Студент выучил все технологии!');
            };
            return this
        },
    };

    let stud = student
    .improveLevel()
    .improveLevel()
    .improveLevel()
    .improveLevel()
    .improveLevel();
    console.log('stud', stud);

Примечание: цепочка из подряд идущих функций improveLevel() работает так, потому что improveLevel() возвращает объект student, а у объекта student есть метод improveLevel().
------------------
/// Глобальный this, globalThis
-------------------
При обращении из глобального контекста к this он будет указывать на глобальный объект. Для браузеров — это объект window
Для всех браузеров - window. Для NodeJS - global
    console.log('this', this);
К глобальному объекту можно также обратиться из любого контекста с помощью глобального свойства globalThis:
    console.log(globalThis);
-------------------
/// this в объекте
-------------------
Как сказано выше, this — это объект, который "владеет" кодом, который сейчас выполняется. Поэтому, при обращении к this из метода объекта, это ключевое слово будет указывать на этот объект:
-------
// Способы создания функций внутри объекта и обращение к ним
-------
* В функциях внутри объектов НЕ стоит ссылаться напрямую к имени объекта, это делает код не универсальным.
* Нужно использовать this.key, вместо user.key 
    const user = {
        name: 'Maxim',
        dateOfBirth: 2001,
        getName() {
        //  return user.name // (дубово, тк привязано к объекту user)
            return this.name // (можно исп. для других пользователей)
        },
        calculateAge() {
            const currentYear = new Date().getFullYear();
            return currentYear - this.dateOfBirth;
        },
        getAllInfo: function() {
            const age = this.calculateAge();
            console.log(`Имя: ${this.name}, Возраст: ${age}`);
        }
    }
    console.log('user.getName:', user.getName());
    console.log('calculateAge:',  user.calculateAge());
    user.getAllInfo();
-------------------
/// bind, call, apply - Методы для привязки к функции какого-то контекста (Применимо только к Функциям.)
-------------------
    const user2 = {
        name: 'Igor'
    }
    const newValueForThis = user.getName.call(user2) 
    console.log('newValueForThis', newValueForThis);

this из объекта user, будет заменен на user2, следовательно и name будет использовано из объекта user2
-------------------
// Различия bind, call, apply
-------------------
    const mainHero = {
        fullName: 'SpiderMan',
        health: 65,
        strength: 5,
    };
    const badHero = {
        fullName: 'SpiderMan',
        health: 55,
        strength: 10,
    }

    function printHeroInfo(extraInfo = '') {
        console.log(`Имя: ${this.fullName}, Здоровье: ${this.health}, Сила: ${this.strength}, ${extraInfo}`);
    }
-------
// Метод call()
-------
    printHeroInfo.call(badHero, 'Роль: Злодей'); 
С помощью call(variable) указываем this какой объект нас интересует
    Пример: this из объекта user, будет заменен на user2, следовательно и name будет использовано из объекта user2
-------
// Метод apply()
-------
    printHeroInfo.apply(badHero, ['Роль: Злодей']); 
Отличия: Метод call() принимает параметры в виде списка через запятую, а apply() — в виде массива:
func.apply(context, [arg1, arg2, ...])
-------
// Метод bind()
-------
    const bindedPrintHeroInfo = 
       printHeroInfo.bind(mainHero, 'Роль: Главный Герой') 
    bindedPrintHeroInfo(); 
Задает контекст this, но не вызывает функцию. При этом он возвращает новую функцию, с заданным this.
---------------------------------------------------------
//// Потеря контекста "this"
---------------------------------------------------------
    const user = {
        name: 'Maxim',
        programmingLang: 'JavaScript',
        getName() {
            return this.name;
        },
        getProgrammingLang() {
            return this.programmingLang;
        },
    }
    console.log('getName:', user.getName()); 
    // getName: Maxim
-------------------
/// Потеря контекста при сохранении объекта.функции в переменную
-------------------
    const newGetName = user.getName
    console.log('newGetName:', newGetName()); 
    // newGetName: undefined. 
Тк мы вызываем функцию newGetName() без контекста(без элемента перед точкой). Поэтому контекст ссылается не на user, а на глобальный объект windows.
-------
// Решение ситуации:
-------
    const newGetName = user.getName
    console.log('newGetName:', newGetName.call(user)); 
    // Через call указали контекст - объект user
-------
    // Если сделать так, то тоже сработает 
    (но потеряет возможность вызывать нужный обьект):
    const newGetName = user.getName() // Вызываем f() тут
    console.log('newGetName:', newGetName); // () уже не надо 

Так же назначение, без ее использования, считается за вызов, это может сбить счетчик:

for (let i = 0; i < 5; i++) {
    let callFn = student0.improveLevel;
    let callForOther = callFn.call(student1); 
    // callFn.call(student1) не применятся далее, воспринимается как лишний вызов функции
    console.log(i, callFn.call(student1));
}
for (let i = 0; i < 5; i++) {
    let callFn = student0.improveLevel;
    let callForOther = callFn.call(student1);
    console.log(i, callForOther); 
    // Вызывается, результат вызовов верен
}
-------------------
/// Пример работы вызова Функции Объекта в другом Объекте
-------------------
    const user = {
        name: 'Maxim',
        programmingLang: 'JavaScript',
        getName() {
            return this.name;
        },
        getProgrammingLang() {
            return this.programmingLang;
        },
    }
    const user2 = {
        name: 'Maxim',
        programmingLang: 'JavaScript',
        getName() {
            return this.name;
        },
        // getProgrammingLang() {
        //     return this.programmingLang;
        // },
    }

    let callFn = user.getProgrammingLang / Чья f() Объекта
    console.log(callFn.call(user2)); / Выводим ее для user2
    // JavaScript

-------------------
/// Пример использования Функций Объектов
-------------------
const footballer = {
    fullName: 'Cristiano Ronaldo',
    attack() {
        console.log(`${this.fullName} сейчас с мячом и начинает атаку!`);
    },
    scoreGoal (sound) {
        console.log(`${this.fullName} забил гол! Вот это да!`);
        this.celebrate(sound);
    },
    celebrate (sound) {
        console.log(sound);
    },
    goToSubstitution: function (newPlayer) {
        console.log(`${this.fullName} уходит на замену. На поле выходит ${newPlayer}`);  
    }
};

    const attack = footballer.attack;
    const score = footballer.scoreGoal;
    const substitute = footballer.goToSubstitution;

    attack.bind(footballer)();
    score.call(footballer, "Сиииии");
    substitute.apply(footballer, ["Paulo Dibala"]);
-------------------
/// Потеря контекста при стрелочных функциях 
-------------------
    getProgrammingLang: () => {
        return this.programmingLang;
    } 
    // У стрелочной функции нет this
-------
Возможно только через "variable: function() {}" или "variable() {}"
    getProgrammingLang: function () {
        return this.programmingLang;
    }
    getProgrammingLang() {
        return this.programmingLang;
    }
---------------------------------------------------------
//// ООП - объектно-ориентированное программирование 
---------------------------------------------------------
/// function и class
-------------------
// Создаем объект с помощью function
-------
    function Animal (name) {
        this.name = name;

        this.getName = function() {
            return this.name;
        }
    }

    console.log('result', Animal('кот')); 
    // Пытаемся вызвать функцию для создания объекта: result undefined
    const cat = new Animal('кот');
    console.log('cat', cat);

----------------------------
// Создаем объект с помощью class (рекомендуется)
----------------------------
// Класс – это шаблон кода для создания объектов.
    * В классе устанавливаются:
    начальные значения (свойства) и поведение (методы).
// constructor() - это спец-я функция которая вызывается в первый же момент, и инициализирует начальные значения.
// Поля - это каждая сущность внутри constructor() 
   (this.name = name, name - поле)
// Методы - Функции в class (getName() - метод)

    class Animal {
        constructor(name) {
            this.name = name;
        }

        getName() {
            return this.name;
        }
    }

    const dog = new Animal('@');
    console.log('dog', dog);
    console.log('dog.name', dog.name);
    console.log('dog.getName', dog.getName());
-------------------
* Представим, что наземные млекопитающие – это класс. 
* У каждого из них есть четыре конечности, два глаза, каждому из них нужно питаться – это свойства с конкретными значениями, они общие для всех объектов. 
* Также животные могут быть домашними или дикими, травоядными или хищниками, ходить на четырех лапах или на двух – это свойства со значениями, которые задаются конкретному объекту. 
* А такие действия, как поспать, поесть, побежать – это методы.

-------------------
/// Создание класса с помощью функции-конструктора
-------------------
Один из способов создать класс - функция или, вернее, функция-конструктор. Это обычные функции, но с двумя соглашениями:
    Имя функции-конструктора должно быть с заглавной буквы.
    Функция-конструктор должна вызываться с помощью оператора new.
Создание и вызов функции-конструктора выглядит следующим образом:
-------
// Класс через функцию-конструктор
-------
    function Class(значениеСвойства) {
    this.названиеСвойства = значениеСвойства;
    this.названиеМетода = function() { /* ... */ };
    };

    const obj = new Class(переданноеЗначение);
-------
    function Pet(type, name) {
    this.type = type;
    this.name = name;
    this.favoriteAction = 'спать';
    this.say = function() {
        console.log(`${this.type} по имени ${this.name} любит ${this.favoriteAction}.`);
    };
    };

    const cat = new Pet('Кот', 'Барсик');

    console.log(cat);
    // Pet {type: 'Кот', name: 'Барсик', favoriteAction: 'спать', say: ƒ}

    cat.say();
    // Кот по имени Барсик любит спать.

-------------------
/// Создание класса с помощью ключевого слова class
-------------------
    class Class {};
    console.log('type of Class:', typeof Class); // type of Class: function
class – это всего лишь разновидность функции.

В случае с class действуют те же правила, что и с функцией-конструктором:
    Имя должно быть с заглавной буквы.
    Вызов происходит с помощью оператора new.
-------
// Создание класса
-------
    class Class {
    constructor(значениеСвойства) {
        this.названиеСвойства = значениеСвойства;
    }
    названиеМетода1() {} // не ставим ","!
    названиеМетода2() {}
    }

    const obj = new Class(переданноеЗначение);
-------
    class Pet {
    constructor(type, name) {
        this.type = type;
        this.name = name;
        this.favoriteAction = 'спать';
    }
    say() {
        console.log(`${this.type} по имени ${this.name} любит ${this.favoriteAction}.`);
    }
    };

    const cat = new Pet('Кот', 'Барсик');

    console.log(cat);
    // Pet {type: 'Кот', name: 'Барсик', favoriteAction: 'спать'}

    cat.say();
    // Кот по имени Барсик любит спать.
-------------------
// Особенности class
-------------------
class нельзя вызвать без оператора new. 
Если попытаться это сделать, то мы получим ошибку:
    class Class {};
    Class();
    // Uncaught TypeError: Class constructor Class cannot be invoked without 'new'
-------
Вывод класса в консоль начинается с 'class...', что открывает возможности для его отслеживания:
    class Class {};
    console.log(Class); // class Class {}
---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------










<label for="логин">Логин</label> -  текст перед полем ввода. Тег "for" связывается с тегом "id" и при нажатии на текст выделяется форма.
<input type="text/password/email/number/range/date/color/message/" id="логин"> - что будет вводиться в поле ввода.

<section id="sex">
    <option value="Мужчина">м</option>
    <option value="Женщина">ж</option>
</section> - выпадающий из прошлого список

<value=""> - атрибут тега, определяет что будет написано
<id=""> и <class=""> - "id" не должно повторяться, "class" может и используется для стилистики
<div></div> - блочный элемент (выделяет и переносит абзацом)
<header>/<footer>/<nav>/<article>/<section (группа для article)>/<aside (для меню слева-справа)> - это все замена <div> для правильной индексации и нормализации поиска сайта

<figure>
   <img src="" alt="">
   <figcaption>Подпись</figcaption> - связывает подпись с картинкой
</figure> 
<details>
   <summary></summary> - Описание и краткое заглавие выпадающего описания
</details>

_______________________________
CSS
   h1       {color: red}
-селектор {свойство: значение}
-cвойство: функции (значение);
.class > p - ображение только к детям класса (не учитывая детей детей)
---------------------------------------------------------
font-family - выбор шрифта (Roboto,Times..)
font-size - размер текста
font-weight - толщина начертание шрифта (аналог <strong>)
text-transform: uppercase - заглавный шрифт
---------------------------------------------------------
width= "150" - устанавливает ширину элемента (ширину области)
word-spacing - растояние между словами
letter-spacing - растояние между символами
line-height - межстрочный интервал
text-decoration: underline; - подчеркивания, зачеркивания, none
<del></del> -зачеркнутый текст или (представляет диапазон текста, который был удалён из документа)
<ins></ins> - подчеркивание или (показывает что было добавлено в код)
opacity: 0.4 - непрозрачность элемента
---------------------------------------------------------
#ff0000 - красный; color: #00ff00 зеленый; color: #00ff00 синий;
color: rgba(0, 255, 0, 0.2) - цвета и прозрачность
-Дизайнт цвета можно копировать с браузера с помощью пипетки из "Иследовать элемент"
---------------------------------------------------------
-CSS код можно писать как в  HTML в <head><style></style></head>
 Можно писать инлайн <header style="color: black;"></header>
 Можно писать так же отдельно в css файле: <link rel="stylesheet" href="Index.css0">
---------------------------------------------------------
padding: 0px 20px 0px 20px - можно написать сразу для 4х сторон. Отсчёт идёт по часовой стрелке.
padding - внутренние отступы (внутри рамки)
margine - внешние отступы (за рамкой)
margin: auto; - выравнивание по центру 
bottom - подвал/низ
top - верх
---------------------------------------------------------
* {} - селектор задает значение всему на странице
#id {} - стилизация через ID: #id {}
.card p {} -для обращения к безликому(повторяющемуся в др местах) дочернему тегу через родительский указываем путь: .card p {}
@import url() - Импорт шрифта
div p - выбор всех элементов p внутри элемента div
---------------------------------------------------------
filter: blur(2px)
filter: grayscale (0%) - сепия
filter: opacity (100%) - непрозрачность
filter: saturate (100%) - насыщенность 
filter: contrast (100%) - контрастность
background: linear-gradient ( 45deg, blue, lightGreen) - градиент
cursor:pointer; - изменение курсора при наведении
---------------------------------------------------------
background-image: url("img/whistle.svg"); - выставление бэкграунд фото
background-repeat: no-repeat; - не размазывать фон (иконки) по всему блоку
background-position: center top; - местоположение бэкграунд изображения (может выступать иконкой, а не фоном сайта)
background-position: right 35% bottom 45%;
background-size: - размер изображения
---------------------------------------------------------
list-style: none или url('/media/examples/rocket.svg'); - что будет показываться в пунктах(точках) списка
---------------------------------------------------------
.cards a:hover {} - интерактивность при наведении на элемент, меняет цвет/размер шрифта итд 
transition: all .2s; - анимация увеличения для селектора (например для ссылки при наведении)
.table:nth-child(odd/even/1/2/3..) - выделение столбцов таблицы
---------------------------------------------------------
Flex
---------------------------------------------------------
Используется для родительского элемента:
<div class="container"><div></div></div>

display: flex; - создаёт флекс контейнер 
flex-direction: row/column; - элементы в строку/ в колонке

.container { justify-content: center; } - установка элемента по центру
justify-content: space-around; - равномерное распределение элементов по контейнеру (space-around/space-between/center/start/end)
---------------------------------------------------------
_______________________________
JavaScript 
JS - регистрозависимый язык
---------------------------------------------------------
Функция isNaN() возвращает true, если значение не число, равно NaN (Not-a-Number), и false, если нет.
---------------------------------------------------------
== 	равно
=== 	равное значение и равный тип
!= 	не равный
---------------------------------------------------------
unshift - Добавление новых элементов в начало массива
var fruits = ["Банан", "Апельсин", "Яблоко", "Манго"];
fruits.unshift("Lemon","Pineapple");
---------------------------------------------------------
Math.max([x[, y[, …]]])- Возвращает наибольшее число из своих аргументов.
---------------------------------------------------------
Массивы: 
let fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits[0] ); // Яблоко
alert( fruits[1] ); // Апельсин
alert( fruits[2] ); // Слива
---------------------------------------------------------
Цикл 
for (начало; условие; шаг) {
  // ... тело цикла ...
}
for (let i = 0; i < 3; i++) { 
   // выведет 0, затем 1, затем 2
  alert(i);
}
---------------------------------------------------------
Чтобы вывести объединить текстовую строку и переменную является знак «+». Чтобы сообщить о том, что здесь закончился текст и начинается переменная Javascript, нужно открыть и закрыть кавычки.
alert( "Привет " + name + "!");
---------------------------------------------------------
<script defer src="js/vendor/jquery.js"></script>
async - выполение сриптов по мере возможности, "рандомно"
defer - выполение в строгой последовательности их размещения
---------------------------------------------------------
Math.floor() - округление вниз. Округляет аргумент до ближайшего меньшего целого.
---------------------------------------------------------
querySelector - "найди и принеси элемент" селектор запросов (en/ru)
document.querySelector('селектор');
document.querySelector('.page'); - js ищет на странице элемент с классом "page"
---------------------------------------------------------
Для добавления js в html, <script></script> добавляется перед </body>
Для подключения js к html необходимо ввести в конце <body> <script src="index.js"></script> </body>
---------------------------------------------------------
Тестирование с помощью консоли (вывод в консоль):
console.log(document.querySelector('.page'));
console.log - обращение к консоли
(document. ___ ) - "документ" поиск по данному файлу 
---------------------------------------------------------
classList.remove - удаление класса 
элемент.classList.remove('класс');
document.querySelector('.page').classList.remove('light-theme');
Сначала ищем селектор, во втором моменте "." не ставится, тк js знает что это класс
---------------------------------------------------------
classList.add - добавление класса 
элемент.classList.add('класс');
---------------------------------------------------------
Переменная — это способ сохранить данные, дав им понятное название (ярлык с файлами).
Константа - почти тоже самое что и переменная, только значение которой нельзя менять
---------------------------------------------------------
let - с помощью него можно создать (обьявить) переменную. 
let: - "пусть/допустим" за которым следует имя для вашей переменной. 
Чтобы задать несколько значений let 
let numbers = [10, 4, 100, -5, 54, 2]; - массив

У переменных после их наименования с помощью "let" должно быть присвоено значение.
" = " - с помощью знака равенства присваиваем значение переменной
let variableName = 'Я значение переменной!';

let header = document.querySelector('header'); - при вводе переменной "header", JS выполняет функцию поиска по документу селектора header
---------------------------------------------------------
Условия / условные выравнивания (Conditionals) - it/else/else if 
---------------------------------------------------------
События (Events) - это действия, которые происходят в браузере, например, нажатие кнопки или загрузка страницы или воспроизведение видео, в ответ на которые мы можем запускать блоки кода.
Конструкции прослушивающие события - прослушиватели событий
Блоки кода выполняемы в ответ на срабатывание события - обработчики событий
---------------------------------------------------------
Циклы (Loops)
for - для / of - из

const fruits = ['apples', 'bananas', 'cherries'];
for (const fruit of fruits) {
  console.log(fruit);
}
Данный цикл будет поочередно выводить значения массива константы "fruits"
Строка for (const fruit of fruits) говорит:
1.Получи первый элемент из fruits.
2.Установи переменную fruit для этого элемента, затем запусти код между скобками {}.
3.Получи следующий элемент из fruits и повторяй, пока не дойдешь до конца.
---------------------------------------------------------
Массив - массив — это набор элементов
Строка const fruit = ['apples', 'bananas', 'cherries']; создает массив.
---------------------------------------------------------
focus() - 
guessField.focus(); помещает курсор в текстовое поле при загрузки страницы 
---------------------------------------------------------
alert() - выводит модальное окно на странице
const years = prompt('Сколько вам лет?', 100);
alert('Вам ' + years + ' лет!')

prompt() - выводит окно с строкой заполнения и его возможным заполнением('Наименование окна','Запись в строке заполнения') 
Сохранить в переменную: const userName = prompt('Как вас зовут?');

confirm() - диалоговое окно с сообщением и кнопками выбора "cancel" - false, "ok" - true.
---------------------------------------------------------
Чтобы вывести в консоль в одну строку несолько параметров:
console.log(`${myInfoText[0]} ${myInfoText[441]}`)
---------------------------------------------------------
Определяем переменную let: 
let name = 'Petr the pig';
Переопределяем и выводим для проверки в консоль:
name = 'Nastya'
console.log("Имя было изменено", name);
Или можно переопределить на другую переменную:
ageOfPerson2 = ageOfPerson1;

Определяем переменную const: 
const programmingLanguage = 'JavaScript';
Константа не переопределяется и выходит ошибка:
programmingLanguage = 'Java'
console.log(Java);
---------------------------------------------------------
В JS 8 типов данных:
- String (строка)
- Number - число
- Boolean - (логический) оперирует только trye/false
- Null - пустое значение или значение неизвестно 
- Undefined - переменная была объявлена, но значение ей не присвоено.
let x;
console.log(x);
(оставь этот вывод значения системе, используй null)
- Object - сложный тип данных, обьединяющий несколько параметров
const car = {
   name: "Toyota Corolla",
   year: 2017,
   isNew: false,
   owner: null
 }
//  Обратиться к свойсту Обьекта:
 console.log(car.name);
- Symbol - нужен для создания уникальных ключей обьекта (невозможно преобразовать в number)
const id = Symbol('id');
console.log(id);
- BigInt - большое число (больше, чем (2⁵³-1), т.е. 9007199254740991).
Для создания переменной этого типа нужно поставить букву n в конце числа: 
let bigNumber = 123456789n;

Как определить тип данных? (например что это строка)
typeof('') или typeof ''
console.log(typeof 'Maxim')
---------------------------------------------------------
// Явное преобразование к строке:
String(_переменная_)
const age = 22;
console.log('string age:', age, typeof String(age)); 

// Явное преобразование к числу:
Number(_переменная_)
'Hello' - выведет NaN (not a number)
'1 2' - выведет NaN (not a number)
let question2 = Number(prompt('Сколько будет 2 * 2?'))

// Явное преобразование к Boolean:
Большинство переменных выводится "true"
null, Undefined, NaN, 0, '' - выводится false ('' - пустая строчка)
'0' - строка, выдаст true
---------------------------------------------------------
// Конкатенация - объединение (например строк, строк строки, поиск нужных символов и фраз)
const name = 'Denis';
const specialization = 'Novice-developer';

// Конкатенация 3 способа:

const allInfo1 = name + ' ' + specialization;
console.log(allInfo1);

const allInfo2 = `${name} ${specialization}`
console.log(allInfo2);

let allInfo3 = name + ' ';
allInfo3 += specialization;
console.log(allInfo3);

"Hello".concat(" T", "p", "r", "o", "g", "e", "r"); // "Hello Tproger"
---------------------------------------------------------
// Узнать длинну строки (length)
const programmingLanguage = 'JavaScript';
console.log(programmingLanguage.length); // 10

// Получение индекса (буквы) строки
   Отсчет идет с 0
console.log(programmingLanguage[4]); // S
console.log(programmingLanguage[44]); // undefined
Или с помощью команды .charAt(0)
   С помощью этого НЕЛЬЗЯ поменять символ 
programmingLanguage[4] = 's'; (не сработает)
   Получаем последний символ
alert( str[str.length - 1] ); // o
---------------------------------------------------------
// toUpperCase, toLowerCase - изменяет на ЗАГЛАВНЫЕ и строчные 
const animal = 'Lion';
console.log('upper', animal.toUpperCase());
console.log('lower', animal.toLowerCase());
console.log(animal); - не изменяет само значение, а создает новое с заглавными или строчными

Слово с заглавной буквы:
const publication = "freeCodeCamp";
publication[0].toUpperCase() + publication.substring(1);

Слова с заглавной буквы:
const mySentence = "freeCodeCamp is an awesome resource";
const words = mySentence.split(" ");
words.map((word) => { 
    return word[0].toUpperCase() + word.substring(1); 
}).join(" ");
---------------------------------------------------------
// indexOf, includes - Найти символы 
   indexOf - найти и вывести индекс элемента
   includes - элемент есть/нет

const myText = 'Здесь должна была быть шутка, но я ее не придумал';
console.log('indexOf', myText.indexOf('о')); // 7
console.log('indexOf', myText.indexOf('шутка')); // 23
console.log('indexOf', myText.indexOf('членоногий')); // -1
console.log('includes', myText.includes('не придумал')); // true
---------------------------------------------------------
// slice, substring (одинаковы) - Если нужно получить символы между определенными индексами
const programmingLanguage1 = 'JavaScript';
console.log('slice', programmingLanguage1.slice(1, 5)); // avaS
console.log('slice', programmingLanguage1.substring(1, 5)); // avaS
---------------------------------------------------------
// replace, replaceAll - Замена (одного и всех)символов символов в строке.
const programmingLanguage2 = 'JavaScript';
console.log('replace', programmingLanguage2.replace('a', 'A')); 
console.log('replaceAll', programmingLanguage2.replaceAll('a', 'A')); 

Для замены несколько раз:
console.log(myInfoText.replaceAll('JavaScript', 'javascript').replaceAll('JS', 'js'));
---------------------------------------------------------
// trim() - удаление лишних пробелов
const nameOfUser = prompt('Ты кто?')
console.log('nameOfUser', nameOfUser.trim());
---------------------------------------------------------
console.log(- 5); // Унарный минус
console.log(10 - 5); // Бинарный минус

// Инкремент и Декримент
let cupsOfCoffe = 2;

cupsOfCoffe = + 5;
cupsOfCoffe += 1;
cupsOfCoffe = * 6; 
cupsOfCoffe = / 2; 
cupsOfCoffe *= 6;
cupsOfCoffe /= 2;
   
// Постфикc и префикс
let cupsCoffe = 0;

console.log('cupsCoffe++:', cupsCoffe++); // Возвращает исходное значение
   
console.log('++cupsCoffe:', ++cupsCoffe);
---------------------------------------------------------
//// Сравнение строк

// Операторы сравнения: 
> < >= <= == ===
Примечание: никогда в разработке веб-приложений не используй нестрогое сравнение ==. Оно является инициатором большого количества багов, так как производит преобразование типов. Используй исключительно строгое сравнение ===. Оно не преобразует типы и уменьшает шанс возникновения ошибок. 

console.log("'Ass' == 'ass'",'Ass' == 'ass'); // false
console.log('"A".charCodeAt()', 'A'.charCodeAt()); // 65
console.log('"a".charCodeAt()', 'a'.charCodeAt()); // 97

// String.fromCharCode() - Получитьв символ в обратную сторону из числа
console.log(String.fromCharCode(97)) // 'a'
console.log(String.fromCharCode(65)) // 'A

// == vs ===
// == сравнивает значения
console.log("'1' == 1", '1' == 1);
console.log("'200' > '21'", '200' > '21');
console.log("true == 1", true == 1);

// === сравнивает типы (рекомендовано)
console.log("1 === 1", 1 === 1)
console.log("true === 1", true === 1)
---------------------------------------------------------
// Math объект
console.log('Math объекты');
console.log('Число Pi', Math.PI); // 3.141592653589793

//// Округление

// Math.round() – простое округление
console.log('Простое округление:');
console.log('Math.round(40.4)', Math.round(40.4)); // 40
console.log('Math.round(40.5)', Math.round(40.5)); // 41
console.log('Math.round(40.6)', Math.round(40.6)); // 41

// Math.floor() – округление вниз
console.log('Округление вниз:');
console.log('Math.floor(40.5)', Math.floor(40.5)); // 40
console.log('Math.floor(40.9)', Math.floor(40.99)); // 40

// Math.ceil() – округление вверх
console.log('Округление вверх:');
console.log('Math.ceil(40.1)', Math.ceil(40.1)); // 41

// .toFixed(x) - обрезает значение
let result = Number((amount / rate).toFixed(2)); // .toFixed(2) - обрезает значение до 2х символов.
---------------------------------------------------------
//// Логические конструкции

if (если да, то)
else (что-то другое)
if else (если другое "да", то)
switch case (случай) - замена else & if
? : - замена else if

//// {if} {else}

if (условие) {
  // Выполнится, если условие будет истинным
} else {
  // Выполнится, если условие будет ложным
}

let isFrontendDeveloper = true;

if (isFrontendDeveloper) {
   console.log('isFrontendDeveloper = true','You are a Front-End developer. Welcome to the team!');
} else {
   console.log('isFrontendDeveloper = false', 'You are not a Front-End developer');
}

const condition = 5 > 10; // вернет false
if (condition) {
  console.log('Выражение истино!');
} else {
  console.log('Выражение ложно!');
}
Вывод: Выражение ложно!

let developerJobType = 'Front-End';

if (developerJobType === 'Front-End') {
   console.log('2000$');
} else if (developerJobType === 'Back-End') {
   console.log('1500$');
} else if (developerJobType === 'Full-Stack') {
   console.log('3500$');
} else {
   console.log('Зарплата не определена');

---------------------------------------------------------
//// switch case / break / default - замена else if

let developerJobType = 'Front-End';

switch (developerJobType) {
   case 'Front-End':
      console.log('2000$');
      break;
   case 'Back-End':
      console.log('1500$');
      break;
   case 'Full-Stack':
      console.log('3500$');
      break;
   default:
      console.log('Зарплата не определена');
---------------------------------------------------------
//// ? : - замена else if

let favoriteDrink = '???'

let message = favoriteDrink === 'Coffe' // условие 
   ? 'Your favorite drink is coffe' 
   // после '?' выполняет если условие 'true'
   : 'You most likely have a healthy CNS'; 
   // после ':' выполняет если условие 'false'

let question2 = prompt ('Сколько будет 2 * 2?') 
    question2 = Number(question2)

   question2 === 2 * 2
   ? alert('Ответ Верный') + correctAnswers++
   : alert('Ответ Неверный') + incorrectAnswers++;

// ? :
// ? if
// : else

console.log('message:', message);
---------------------------------------------------------
// && (И) - Ищет и выводит значение с "false". Значения  "true" пропускаются.
// || (ИЛИ) - Ищет и выводит значение с "true". Значения  "false" пропускаются.
// ! (НЕ)
// ?? (Оператор обьединения с null) - Пропускает только значения "null" и "undefined" 

//// && (И) - Ищет и выводит значение с "false". Значения  "true" пропускаются.
Пропускает алгоритм далее если оба значения true:
if (existingUserLogin === userLogin && existingUserPassword === userPassword) {
  alert(`Добро пожаловать, ${userLogin}!`);
} else {
  alert("Логин и (или) Пароль введены неверно!");
}

console.log('//&& (И)//');

let userAge = 20;

if (userAge > 6 && userAge <= 18) {
   console.log('Пользователь ходит в школу');
} else {
   console.log('Пользователь НЕ ходит в школу');
}


let programingLanguage = 'JavaScript'
let experienceInYear = 1;

if (programingLanguage === 'JavaScript' && experienceInYear >= 1) {
   console.log('Добро пожаловать в нашу команду');
} else {
   console.log('Нужно бооольше опыта');
}

//// || (ИЛИ) - Ищет и выводит значение с "true". Значения  "false" пропускаются.

let currentHour = 10;

if (currentHour < 8 || currentHour > 20) {
   console.log('Наш офис Закрыт');
} else {
   console.log('Наш офис Открыт');
}


let userNickname = null;
let defaultNicname = 'User';

let nickname = userNickname || defaultNicname || 'noname';
console.log('nickname', nickname);

//// ! (НЕ)
let = answer = prompt ('How old are you?')
answer = Number(answer);

if (!answer) {
   alert('Enter your total number of years')
} else {
   alert(`You are ${answer} years old`)
}

Предположим, у нас есть сайт и мы хотим сделать какие-то действия, если пользователь не авторизован. Также у нас есть переменная isAuth:
let isAuth = false; //if (existingUserPassword === userPassword) {
   alert (`Добро пожаловать, ${userPassword}`)
} Пользователь не авторизован

if (!isAuth) {
  // Пользователь не авторизован, условие выполнится
}
Условие сработает, так как !isAuth === true и в if будет передано true. 

//// ?? (Оператор обьединения с null)

// ?? - undefined, null 
console.log(false ?? 'Hello worldblat!');

// || - false, 0, "", NaN, indefined, null
console.log(false || 'Hello worldblat!');

---------------------------------------------------------
//// Циклы 
---------------------------------------------------------
// Переменные в циклах не видны за их пределами. 
// Чтобы переменные были видны ни только в цикле о и за ним, неоюходимо создать этупеременную заранее.

//// for () {}

// for (начальное значение; условие (до тех пор пока); шаг) {
   ... тело цикла ...
}

   for (let x = 0; x <= 10; x += 1) {
      console.log('x = ', x);
   }

   for (let value = 10; value >= 0; value -= 1) {
      console.log('value = ', value);
   }

   for (let i = 0; i < 3; i += 1) {
      let newStudent = prompt("Введите имя нового студента!");
      if (newStudent) {
      newStudent = newStudent.trim();
      alert(`Добро пожаловать, ${newStudent}!`);
      }
   } // Будет повторять вывод тела функции (Вопрос об имени, Приветствие + Имя)  3 итерации, до тех пор пока (i < 3)

   let sequence = [1, 1, 2, 3, 5, 8, 13];
   for (let i = 0; i < sequence.length; i++) {
   console.log(sequence[i]);
   } 
   // 1, 1, 2, 3, 5, 8, 13
   // Цикл выводит следующее значение в консоль по порядку, тк указано sequence[i]. sequence с индексом [i] на начальном этапе подразумевает что i = 0 (тк отсчет указан с 0), а даной цифре отсчета соотвествует индекс массива [0], в данном случае индекс массива sequence[0] = 1. А тк i++, цикл движется дальше на +1 ход вперед к следующему индексу массива.

// function calculateFlights (distance, isBusinessClass, milesTarget) {
      // body //
   };
   
   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   let flightsVariant1 = calculateFlights(3118, true, targets[i]);
   let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   for (let i = 0; i < targets.length; i++) {
      flightsVariant1();
      flightsVariant2(); 

   // Так не сработает! "ReferenceError: i is not defined". 
   // flightsVariant1/2 - как не знал до этого так и не знает что за значение "i"."i" становится известно лишь после обьявления цикла.

   let targets = [Saskatoon = 3000, Asuncion = 7000,Tokio = 15000];
   for (let i = 0; i < targets.length; i++) {
      let flightsVariant1 = calculateFlights(3118, true, targets[i]);
      let flightsVariant2 = calculateFlights(3617, false, targets[i]);

   // Так сработает!

---------------------------------------------------------
//// Замена for (без возможности использовать инедекс i)

const userNames = ['petya', 'vasya', 'evgeny'];

// name на каждой итерации свой собственный (локальный), поэтому используется const
for (const name of userNames) {
  console.log(name);
}
   // => "petya"
   // => "vasya"
   // => "evgeny"

---------------------------------------------------------
//// while - сначала думает (смотрит условие), потом делает
console.log('//while//');

// while (условие) {}

   let i = 0;
   while (i < 10) {
      console.log('i = ', i);
      i += 1;
   }

---------------------------------------------------------
//// do while - сначала делает, потом думает (смотрит условие)

   let i = 0;
   do {
      i += 1
      console.log('i = ', i);
   } while (i <= 5) // Выдаст 6, начав с 1 (тк сначала делает, а потом проверяет. Важна последовательность)

   let i2 = 0;
   do {
      console.log('i2 = ', i2);
      i2 += 1
   } while (i2 <= 5) // Выдаст 5, начав с 0 

---------------------------------------------------------
//// break 

   let z = 0;
   while (z < 10) {
   console.log(z);
   if (z === 3) break;
   z++;
   }
Остановится на 3х. Выведет: 0 1 2 3

---------------------------------------------------------
//// continue 

   for (let f = 0; f <= 5; f++) {
      if (f === 2) continue;
      console.log(f);
   }
Пропустит 2. Выведет: 0 1 3 4

---------------------------------------------------------
//// Массив - это набор элементов

let target = [
   {nameTown:'Saskatoon', km: 3000}, 
   {nameTown:'Asuncion', km: 7000}, 
   {nameTown:'Tokio', km: 15000}
   ];

   for (let i = 0; i < target.length; i++) {
      const el = target[i];
      console.log(`Town name: ${el.nameTown} km: ${el.km}`);
   }
//Or
   target.forEach(el => console.log(el.nameTown)); // Saskatoon Asuncion Tokio
   target.forEach(el => console.log(el.km)); // 3000 7000 15000


 
let fruits = ["Яблоко", "Апельсин", "Слива"];
   alert( fruits[0] ); // Яблоко
   alert( fruits[1] ); // Апельсин
   alert( fruits[2] ); // Слива


let numbers = [0, 0, 0, 0, 1];
let sum = 0;

for (let i = 0; i < numbers.length; i += 1) {

   numbers[i] = numbers[i] + 2; 
   // При каждом проходе цикла прибавляет к "i" +1, что пошагово продвигает цикл по элементам [ ] массива "numbers".
   Будет получаться:
   numbers = [2, 0, 0, 0, 1]; - 1й проход цикла
   numbers = [2, 2, 0, 0, 1]; - 2й проход цикла
   numbers = [2, 2, 2, 0, 1]; - 3й проход цикла
   numbers = [2, 2, 2, 2, 1]; - 4й проход цикла
   numbers = [2, 2, 2, 2, 3]; - 5й проход цикла

   sum = sum + numbers[i];
   // Складывает к переменной "sum" актуальное значение массива (в зависимости на какой позиции сейчас находится цикл)
   sum = 0 + 2 = 2
   sum = 2 + 2 = 4
   sum = 4 + 2 = 6
   sum = 6 + 2 = 8
   sum = 8 + 2 = 11
}
console.log(sum); // 11

// Выявить min / max значение из массива:

   let arr = [22,4,7];
   console.log(Math.min(...arr));

// разные типы значений
   let arr = [ 'Яблоко', { name: 'Джон' }, true, function() { alert('привет'); } ];

   получить элемент с индексом 1 (объект) и затем показать его свойство
   alert( arr[1].name ); // Джон

   получить элемент с индексом 3 (функция) и выполнить её
   arr[3](); // привет

// let cities = [
   {Valencia: 3118}, 
   {Lisbon: 3617}, 
   {Saskatoon: 3000}, 
   {Asuncion: 7000}
   ];

(cities[0].Valencia); // 3118
(cities[0]); // { Valencia: 3118 }
---------------------------------------------------------
// array.forEach()

Метод используется для перебора массива.

   arr.forEach(function callback(item, index, array)){
      ... делать что-то с item
      }); 

Он для каждого элемента массива вызывает функцию callback.
Этой функции он передаёт три параметра callback(item, i, array):
    item – очередной элемент массива.
    i – его номер.
    array – массив, который перебирается.

Например, этот код выведет на экран каждый элемент массива:
   ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
 // Вызов alert для каждого элемента

А этот вдобавок расскажет и о своей позиции в массиве:
   ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
   alert(`${item} имеет позицию ${index} в ${array}`);
   });

///  arr = [
      {name:'Saskatoon', value: 3000}, 
      {name:'Asuncion', value: 7000}, 
      {name:'Tokio', value: 15000}
   ];

   arr.forEach(el => console.log(el.name));
   arr.forEach(el => console.log(el.value));

---------------------------------------------------------
// Array.length - число элементов этого массива

let items = ['shoes', 'shirts', 'socks', 'sweaters'];
console.log(items.length); // 4
---------------------------------------------------------
//// Функции 
     С помощью них предотвращают дублирование кода. 
     Функция вызывается добавлением () после нее
   
В функцию мы можем передавать параметры (любые типы данных). Одним из параметров может быть другая функция (например callback, alert, console.log) 

// Function Declaration - обьявление функции
   (Можем вызывать функцию до ее определения)
   
   function name(param) {}

   function sum0 (a = 1, b = 3) {
      console.log(a + b);
   }
   sum0(); // 4
// Or
   function sum1 (a, b) {
      console.log(a + b);
   }
   sum1(1, 3); // 4
// Or
   function sum2 (a, b = 3) {
      console.log(a + b);
   }
   sum2(1); // 4
---------------------------------------------------------
//// Callback — это функция, в основной функции, которая должна быть выполнена после того, как другая (вторая) функция завершила выполнение (отсюда и название: callback — функция обратного вызова).

   function sum03(a, b, callback) {
   const result = a + b;
   callback(result);
   }

   function displayer(res) {
      console.log('Результат:', res);
   }

   sum03(3, 10, displayer);

/* Что тут происходит?
Создаем функцию sum03 с параметрами 'a', 'b', 'callback' 
(параметрами могут быть любые данные, даже функции, как и callback в данном случае.)
'callback' - это лишь произвольное название функции (хотя тут больше похоже на переменную со значением, чем на функцию. Но так как callback принимает значение от функции - это функция), в которую мы далее будем передавать полноценную функцию со значениями displayer. 

Создаем переменную result которая выполняет сложение двух неизвестных переменных 'a' и 'b' (пока их значение undefined)

Назначаем что функция callback будет иметь и выводить параметр result который хранит результат сложения.

Далее создаем функцию с наименованием displayer.
(которая в дальнейшем будет назначена передавать свое значение в callback. По сути можно сказать что callback = displayer)

Функция displayer имеет параметр res.
Далее тело функции displayer будет выводить в консоле строку 'Результат:' и переменную res (которую перенимает значения из result)

Далее самое важное. Мы передаем (назначаем) наши параметры функции sum 
Теперь (a, b, callback) = (3, 10, displayer)
a = 3
b = 10
callback = функция displayer

Грубо говоря, общая картина такова, что сумма значений 
(a + b) = result
result = callback 
callback = displayer
А так как displayer передает значения в callback, а callback хранит в себе значение переменной result, то есть сумму (a + b), то для функции displayer нам необходимо сохранить это значение в переменную res.

3 + 10 = 13. Помещается в функцию (параметр) callback и храниться в переменной result в качестве параметра.
А наш параметр callback является функцией displayer которая так же хранит в себе аналогичную переменню res в качестве параметра.

Получается displayer это отражение callback, которая хранит в себе все ее значения с небольшими дополненеиями. Которая могла бы вызываться по необходимости (в конце), то есть отдельно от выполнения главноего тела функции sum, где участвует callback.
*/

// Или это же, но через анонимную функцию (без названия)

   function sum04(a, b, anon_function) {
      const result = a + b;
      anon_function(result);
   }

   sum04(5, 10, function(res01) {
      console.log('Результат:', res01);
   });

// callback с уже существующими функциями 

   function sum05(a, b, alert) {
      const result = a + b;
      alert('Результат: ' + result);
   }

   sum05(5, 11, alert)
   
---------------------------------------------------------
//// Return - позволяет вернуть результат(значение) из функции 
*return - останавливает выполнение функции

// let increaseByTwo = function (number) {
      let sum = 2 + number;
      return sum;
   };

   increaseByTwo(1); // Функция вернёт 3
   increaseByTwo(2); // Функция вернёт 4

Чтобы функция вернула значение, мы используем оператор return. После оператора указываем, что именно надо вернуть. В нашем случае значение переменной sum. Когда программа доходит до строки с return, функция отдаёт результат своей работы и выполнение кода из тела функции останавливается, иными словами происходит выход из функции.

Несколько вещей, которые нужно знать:

   -Код, написанный на новой строке после return, не выполняется.
   -Функция не может вернуть сразу много значений, она возвращает только один результат.
   -Если внутри функции нет return или после return не указано, какое значение нужно вернуть, функция вернёт undefined, иными словами, ничего.

---------------------------------------------------------
Обрати внимание на разницу между параметрами и аргументами. На практике зачастую эти слова взаимозаменяемы, но стоит понимать отличия:

    Параметр — это название переменной, которое указывается в объявлении функции. Они используются для многоразовости функции, для подставления в нее разных аргументов на место ярлыков(параметров). (price, count)
    Аргумент — это значение параметра, которое передается при вызове функции. (100, 5)

   function showTotalPrice(price, count) {
   console.log(price * count);
   };
   Данная функция имеет два параметра — цена (price) и количество (count). По сути это переменные, которым присваиваются значения при вызове функции.

   showTotalPrice(100, 5); // Выведет в консоль: 500
   showTotalPrice(350, 2); // Выведет в консоль: 700
   // Аргументы (100, 5)

   
---------------------------------------------------------

// document.querySelector('.селектор') - найти элемент
   console.log(document.querySelector('.селектор')) - удостовериться, что найден нужный элемент

// .classList.remove - удалить класс
   document.querySelector('.page').classList.remove('light-theme') - удалить класс в найденном селекторе

// .classList.add('dark-theme') - добавить класс
   document.querySelector('.page').classList.add('dark-theme');  - добавить класс в найденном селекторе 

Но это некорректная запись. Для нормализации читабельности, скорости и удобства кода назначим переменной значение поиска, чтобы не искать ее каждый раз.

   let page = document.querySelector('.page');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
   
///

   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.remove('light-theme');
   page.classList.add('dark-theme');
   };

'onclick' свойство (по клику) - это событие для браузера 

Данная конструкция создает переменную которая будет хранить в себе найденный класс с кнопкой для смены темы сайта.
При нажатии на кнопку будет запущенна функция удаления светлой темы и добавления темной.

// .classList.toggle - чередование переключения классов.
Удаляет(remove) если есть, добавляет(add) если нет.

   селектор.classList.toggle('класс');
   page.classList.toggle('light-theme');

Итого код для переключения темы:
   let themeButton = document.querySelector('.theme-button');

   themeButton.onclick = function() {
   console.log('Кнопка нажата!');
   page.classList.toggle('light-theme');
   page.classList.toggle('dark-theme');
   };

---------------------------------------------------------
// .textContent - выводит именно текст класса или селектора, а не код вместе с текстом

   let message = document.querySelector('.subscription-message');
   console.log(message.textContent);

С помощью .textContent можно переназначить текст
message.textContent = 'Измененный текст'
---------------------------------------------------------
'onsubmit' свойство - триггер на событие отправки формы (не кнопки!)

   let message = document.querySelector('.subscription-message');
   let form = document.querySelector('.subscription');

   form.onsubmit = function(evt) {
   // Инструкция ниже отменяет отправку данных
   evt.preventDefault();
   message.textContent = 'Форма отправлена!';
   };

---------------------------------------------------------
Отличия Function Declaration и Function Expression в том 
что FD мы можем вызывать до определения функции, а FE нет
---------------------------------------------------------
//// Рефакторинг 

Разработчики рефакторят свой код для того, чтобы он был понятен коллегам и самому автору через какое-то время, легко поддерживался, не содержал в себе повторов, огромных сложных конструкций и так далее. Здесь, как в школе: сначала пишем в черновик, пробуем, зачёркиваем, пробуем снова, пока не придём к решению, а потом аккуратно выводим в чистовик.

При этом рефакторингом занимаются все, даже самые крутые рок-звёзды из мира разработки.
---------------------------------------------------------
 Хороший код всегда состоит из множества частей, каждая из которых занимается только своей задачей.
---------------------------------------------------------
//// Arrow Function Expression
// Символ "=>" заменяет термин "function"

   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   };
   let result = sum(3.14, 3.14);
   console.log('Result:', result);

// Создаем имя функции "sum", вводим в () параметры, с помощью => обозначаем что это стрелочная функция которая переходит к телу {}. После "=>" без указания "{}", дальнейший текст будет воспринят как для команды "return".

   const sayHello = () => {
      alert("Hello");
   };

   const sayHello = (name) => {
      alert(`Hello, ${name}`);
   };  

const sayHello = name => alert(`Hello, ${name}`);
const calc = (a, b) => a + b;

sayHello("Vasya"); // Выведет сообщение "Hello, Vasya"
console.log(calc(1, 2)) // Выведет в консоль: 3

   let sum = function (a, b) {
      return a + b
   } 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => {
      let calculate = a + b;
      return calculate;
   }

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
//Or
   let sum = (a, b) => a + b; 

   let result = sum(3.14, 3.14);
   console.log('Result:', result);
   // Только если функция состоит из 1 строчки

---------------------------------------------------------
//// Использование Arrow Function как callback

   function multiply (a, b, callback) {
      const result = a * b;
      callback(result);
   }

   multiply(5, 2, (multiplyResult) => {
      console.log('multiplyResult:', multiplyResult);
   });

---------------------------------------------------------
//// Замыкания - функция внутри функции

// Замыкания — это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.
// Свободные переменные — это переменные, которые не объявлены локально и не передаются в качестве параметра.

   let numberGenerator = function() {
// Локальная переменная, которая доступна только в замыкании
   var num = 1;
   function checkNumber() {
      console.log(num);
   }
   num++;
   return checkNumber;
   }

   var number = numberGenerator();
   number(); // 2

В примере функция numberGenerator создаёт локальную «свободную» переменную num (число) и checkNumber (функция, которая выводит число в консоль). 
Функция checkNumber не содержит собственной локальной переменной, но благодаря замыканию она имеет доступ к переменным внутри внешней функции, numberGenerator. 
Поэтому объявленная в numberGenerator переменная num будет успешно выведена в консоль, даже после того, как numberGenerator вернёт результат выполнения.

Если посмотреть Debuger, то clg функции checkNumber будет выполняться последним. Почему? Тк идет передача этой функции в главную, с помощью return. А при вызове главной функции number(), следовательно и вызывается clg функции checkNumber.

-------------Разбор примера-------------
const createCounter = (initialValue = 0) => {
   return (valueToAdd) => {
      return initialValue + valueToAdd
   };
};

const addFive = createCounter(5);
const result = addFive(7);
console.log(result);

// Смотрим процесс черз Debuger. До момента с назначением аргумента (5) функции createCounter все понятно. Далее это значение с параметром, упаковывается в переменную addFive. 
После, уже нынешняя переменная addFive(тобишь createCounter(5)) двигается далее и встречает return(1*), который возвращает в наш addFive вложенную анонимную функцию(со всеми ее значеними). 
То есть, теперь наш addFive != createCounter(5)
А имеет значение addFive = (valueToAdd) => {
      return initialValue + valueToAdd
   };
Это Debuger обработал первый(1*) return.
После процесс Debuger видит новый аргумент addFive(7)и переключается на него, одновременно упаковывая эти значения в переменную result.
И теперь самый важный момент. 
Параметр addFive стал (7). Но тут важно не ошибиться, addFive != исходному createCounter(5)
addFive имеет значение стрелочной функции с параметром (valueToAdd).
Поэтому при обьявлении addFive(7), меняется параметр (valueToAdd). А дальше уже все понятно. Этот параметр используется в return для возврата initialValue + valueToAdd. 
Которые в итоге возвращаются в их анонимную стрелочную функцию которая = переменой addFive, которая уже ныне = переменой result, которая в последствии и выводится в консоль.

   createCounter = (initialValue = 0) => {
      let counter = initialValue;

      return (valueToAdd) => {
         counter += valueToAdd;
         return counter;
      };
   };

   const addTwo = createCounter(2);
   result = addTwo(10); // 12
   result = addTwo(5);
   result = addTwo(3);
   console.log(result);

---------------------------------------------------------
//// Область видимости переменных

/// Глобальная область видимости
Позволяет переменной быть видимой из любой точки кода. Переменная считается глобальной, когда она объявлена вне функций и блоков:
const x = 10; // Глобальная переменная

   function show() {
   console.log(x); // Выведет 10
   }

/// Локальная область видимости (3 вида):
// Блочная -
Область видимости ограничена блоком кода (т.е. фигурными скобками { и }):

   if (true) {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined
   / Переменная x будет доступна только внутри блока if

   // Исключение — var. Они не имеют блочной области видимости и доступны даже вне блока.

// Область видимости функции -
Ограничена функцией, в которой объявлена переменная (Аналогично блочному)

   function test() {
   const x = 10;
   }
   console.log(x); // Ошибка ReferenceError: x is not defined

// Модульная — область видимости ограничена модулем.

---------------------------------------------------------
/// Алгоритм поиска переменных движком JS

   const x = 10;

   function show() {
   const y = 20;

   if (true) {
      const z = 30;
      console.log(x + y + z);
   }
   }
   show(); // Выведет в консоль 60   

В данном примере функция show() выводит в консоль сумму трёх переменных. При обращении к переменной x, движок JavaScript действует по такому алгоритму:

    Пытается найти переменную с именем x внутри блока if. Не найдя её, переходит к родительскому блоку наверх.
    Пытается найти переменную x в функции show(). Не найдя её, переходит к глобальному контексту.
    Находит глобальную переменную x и использует её значение.
    
   / Поиск происходит изнутри наружу. От локальных (точка отправления) к более глобальным

// При этом, если во внутреннем блоке уже найдена переменная с нужным именем, поиск останавливается:
   const x = 10;
   
   if (true) {
   const x = 20;
   console.log(x); // Выведет 20
   }
   console.log(x); // Выведет 10

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------

---------------------------------------------------------









